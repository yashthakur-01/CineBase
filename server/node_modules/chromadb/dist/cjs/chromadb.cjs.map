{"version":3,"sources":["../../src/index.ts","../../src/deno.ts","../../src/types.ts","../../../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-core/src/auth.ts","../../../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-core/src/bodySerializer.ts","../../../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-core/src/pathSerializer.ts","../../../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/src/utils.ts","../../../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/src/client.ts","../../src/api/client.gen.ts","../../src/api/sdk.gen.ts","../../src/errors.ts","../../src/utils.ts","../../src/embedding-function.ts","../../src/collection-configuration.ts","../../src/execution/expression/common.ts","../../src/execution/expression/where.ts","../../src/execution/expression/key.ts","../../src/execution/expression/limit.ts","../../src/execution/expression/select.ts","../../src/execution/expression/rank.ts","../../src/execution/expression/groupBy.ts","../../src/execution/expression/search.ts","../../src/execution/expression/searchResult.ts","../../src/schema.ts","../../src/collection.ts","../../src/next.ts","../../src/chroma-fetch.ts","../../src/admin-client.ts","../../src/chroma-client.ts","../../src/cloud-client.ts"],"sourcesContent":["/**\n * @fileoverview ChromaDB JavaScript client library entry point.\n * Provides access to all public APIs for interacting with ChromaDB.\n */\n\n// Apply Deno compatibility patch\nimport \"./deno\";\n\nexport { Collection } from \"./collection\";\nexport { withChroma } from \"./next\";\nexport * from \"./types\";\nexport * from \"./admin-client\";\nexport * from \"./chroma-client\";\nexport * from \"./embedding-function\";\nexport * from \"./cloud-client\";\nexport * from \"./errors\";\nexport * from \"./collection-configuration\";\nexport * from \"./execution\";\nexport * from \"./schema\";\n","// Deno compatibility patch for @hey-api/client-fetch\n// This must be imported before any @hey-api/client-fetch code\n\nif (typeof (globalThis as any).Deno !== \"undefined\") {\n  // Store the original Request constructor\n  const OriginalRequest = globalThis.Request;\n\n  // Create a patched Request constructor that strips Deno-incompatible properties\n  const PatchedRequest = function (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ) {\n    if (init && typeof init === \"object\") {\n      const cleanInit = { ...init };\n      if (\"client\" in cleanInit) {\n        delete (cleanInit as any).client;\n      }\n      return new OriginalRequest(input, cleanInit);\n    }\n    return new OriginalRequest(input, init);\n  } as any;\n\n  // Copy over static properties and prototype\n  Object.setPrototypeOf(PatchedRequest, OriginalRequest);\n  Object.defineProperty(PatchedRequest, \"prototype\", {\n    value: OriginalRequest.prototype,\n    writable: false,\n  });\n\n  // Replace the global Request constructor\n  globalThis.Request = PatchedRequest;\n}\n","import {\n  GetUserIdentityResponse,\n  Include,\n  IndexStatusResponse,\n  SparseVector,\n} from \"./api\";\n\n/**\n * User identity information including tenant and database access.\n */\nexport type UserIdentity = GetUserIdentityResponse;\n\n/**\n * Read level controls whether queries read from the write-ahead log (WAL).\n *\n * - INDEX_AND_WAL: Read from both the compacted index and the WAL.\n *   All committed writes will be visible. This is the default.\n * - INDEX_ONLY: Read only from the compacted index, skipping the WAL.\n *   Recent writes that haven't been compacted may not be visible, but queries are faster.\n */\nexport const ReadLevel = {\n  INDEX_AND_WAL: \"index_and_wal\",\n  INDEX_ONLY: \"index_only\",\n} as const;\n\nexport type ReadLevel = (typeof ReadLevel)[keyof typeof ReadLevel];\n\n/**\n * Re-export SparseVector type for external use\n */\nexport type { SparseVector };\n\n/**\n * Metadata that can be associated with a collection.\n * Values must be boolean, number, or string types.\n */\nexport type CollectionMetadata = Record<\n  string,\n  boolean | number | string | SparseVector | null\n>;\n\n/**\n * Metadata that can be associated with individual records.\n * Values must be boolean, number, or string types.\n */\nexport type Metadata = Record<\n  string,\n  boolean | number | string | SparseVector | null\n>;\n\n/**\n * Base interface for record sets containing optional fields.\n */\nexport interface BaseRecordSet {\n  /** Array of embedding vectors */\n  embeddings?: number[][];\n  /** Array of metadata objects */\n  metadatas?: Metadata[];\n  /** Array of document text content */\n  documents?: string[];\n  /** Array of URIs/URLs */\n  uris?: string[];\n}\n\nexport const baseRecordSetFields = [\n  \"ids\",\n  \"embeddings\",\n  \"metadatas\",\n  \"documents\",\n  \"uris\",\n];\n\n/**\n * Complete record set with required IDs for operations like add/update.\n */\nexport interface RecordSet extends BaseRecordSet {\n  /** Array of unique record identifiers */\n  ids: string[];\n}\n\nexport interface PreparedRecordSet extends Omit<RecordSet, \"embeddings\"> {\n  embeddings?: number[][] | string[];\n}\n\nexport interface PreparedInsertRecordSet extends PreparedRecordSet {\n  embeddings: number[][] | string[];\n}\n\nexport const recordSetFields = [...baseRecordSetFields, \"ids\"];\n\n/**\n * Record set for query operations with required embeddings.\n */\nexport interface QueryRecordSet extends BaseRecordSet {\n  /** Optional array of record IDs to filter by */\n  ids?: string[];\n  /** Array of query embedding vectors (required for queries) */\n  embeddings: number[][];\n}\n\ntype LiteralValue = string | number | boolean;\n\ntype LogicalOperator = \"$and\" | \"$or\";\n\ntype WhereOperator = \"$gt\" | \"$gte\" | \"$lt\" | \"$lte\" | \"$ne\" | \"$eq\";\n\ntype InclusionExclusionOperator = \"$in\" | \"$nin\";\n\ntype OperatorExpression =\n  | { $gt: LiteralValue }\n  | { $gte: LiteralValue }\n  | { $lt: LiteralValue }\n  | { $lte: LiteralValue }\n  | { $ne: LiteralValue }\n  | { $eq: LiteralValue }\n  | { $and: LiteralValue }\n  | { $or: LiteralValue }\n  | { $in: LiteralValue[] }\n  | { $nin: LiteralValue[] };\n\n/**\n * Where clause for filtering records based on metadata.\n * Supports field equality, comparison operators, and logical operators.\n */\nexport type Where =\n  | { [key: string]: LiteralValue | OperatorExpression }\n  | { $and: Where[] }\n  | { $or: Where[] };\n\ntype WhereDocumentOperator =\n  | \"$contains\"\n  | \"$not_contains\"\n  | \"$matches\"\n  | \"$not_matches\"\n  | \"$regex\"\n  | \"$not_regex\"\n  | LogicalOperator;\n\n/**\n * Where clause for filtering based on document content.\n * Supports text search operators and logical combinations.\n */\nexport type WhereDocument =\n  | { $contains: string }\n  | { $not_contains: string }\n  | { $matches: string }\n  | { $not_matches: string }\n  | { $regex: string }\n  | { $not_regex: string }\n  | { $and: WhereDocument[] }\n  | { $or: WhereDocument[] };\n\n/**\n * Enum specifying which fields to include in query results.\n */\nexport enum IncludeEnum {\n  /** Include similarity distances in results */\n  distances = \"distances\",\n  /** Include document text content in results */\n  documents = \"documents\",\n  /** Include embedding vectors in results */\n  embeddings = \"embeddings\",\n  /** Include metadata objects in results */\n  metadatas = \"metadatas\",\n  /** Include URIs in results */\n  uris = \"uris\",\n}\n\n/**\n * Result class for get operations, containing retrieved records.\n * @template TMeta - The type of metadata associated with records\n */\nexport class GetResult<TMeta extends Metadata = Metadata> {\n  public readonly documents: (string | null)[];\n  public readonly embeddings: number[][];\n  public readonly ids: string[];\n  public readonly include: Include[];\n  public readonly metadatas: (TMeta | null)[];\n  public readonly uris: (string | null)[];\n\n  /**\n   * Creates a new GetResult instance.\n   * @param data - The result data containing all fields\n   */\n  constructor({\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris,\n  }: {\n    documents: (string | null)[];\n    embeddings: number[][];\n    ids: string[];\n    include: Include[];\n    metadatas: (TMeta | null)[];\n    uris: (string | null)[];\n  }) {\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n\n  /**\n   * Converts the result to a row-based format for easier iteration.\n   * @returns Object containing include fields and array of record objects\n   */\n  public rows() {\n    return this.ids.map((id, index) => {\n      return {\n        id,\n        document: this.include.includes(\"documents\")\n          ? this.documents[index]\n          : undefined,\n        embedding: this.include.includes(\"embeddings\")\n          ? this.embeddings[index]\n          : undefined,\n        metadata: this.include.includes(\"metadatas\")\n          ? this.metadatas[index]\n          : undefined,\n        uri: this.include.includes(\"uris\") ? this.uris[index] : undefined,\n      };\n    });\n  }\n}\n\n/**\n * Interface for query results in row format.\n * @template TMeta - The type of metadata associated with records\n */\nexport interface QueryRowResult<TMeta extends Metadata = Metadata> {\n  /** Similarity distance to the query (if included) */\n  distance?: number | null;\n  /** Document text content (if included) */\n  document?: string | null;\n  /** Embedding vector (if included) */\n  embedding?: number[] | null;\n  /** Unique record identifier */\n  id: string;\n  /** Record metadata (if included) */\n  metadata?: TMeta | null;\n  /** Record URI (if included) */\n  uri?: string | null;\n}\n\n/**\n * Result class for query operations, containing search results.\n * @template TMeta - The type of metadata associated with records\n */\nexport class QueryResult<TMeta extends Metadata = Metadata> {\n  public readonly distances: (number | null)[][];\n  public readonly documents: (string | null)[][];\n  public readonly embeddings: (number[] | null)[][];\n  public readonly ids: string[][];\n  public readonly include: Include[];\n  public readonly metadatas: (TMeta | null)[][];\n  public readonly uris: (string | null)[][];\n\n  /**\n   * Creates a new QueryResult instance.\n   * @param data - The query result data containing all fields\n   */\n  constructor({\n    distances,\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris,\n  }: {\n    distances: (number | null)[][];\n    documents: (string | null)[][];\n    embeddings: (number[] | null)[][];\n    ids: string[][];\n    include: Include[];\n    metadatas: (TMeta | null)[][];\n    uris: (string | null)[][];\n  }) {\n    this.distances = distances;\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n\n  /**\n   * Converts the query result to a row-based format for easier iteration.\n   * @returns Object containing include fields and structured query results\n   */\n  public rows(): QueryRowResult<TMeta>[][] {\n    const queries: {\n      distance?: number | null;\n      document?: string | null;\n      embedding?: number[] | null;\n      id: string;\n      metadata?: TMeta | null;\n      uri?: string | null;\n    }[][] = [];\n\n    for (let q = 0; q < this.ids.length; q++) {\n      const records = this.ids[q].map((id, index) => {\n        return {\n          id,\n          document: this.include.includes(\"documents\")\n            ? this.documents[q][index]\n            : undefined,\n          embedding: this.include.includes(\"embeddings\")\n            ? this.embeddings[q][index]\n            : undefined,\n          metadata: this.include.includes(\"metadatas\")\n            ? this.metadatas[q][index]\n            : undefined,\n          uri: this.include.includes(\"uris\") ? this.uris[q][index] : undefined,\n          distance: this.include.includes(\"distances\")\n            ? this.distances[q][index]\n            : undefined,\n        };\n      });\n\n      queries.push(records);\n    }\n\n    return queries;\n  }\n}\n\n/**\n * Re-export IndexStatusResponse type for external use\n */\nexport type IndexingStatus = IndexStatusResponse;\n","export type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","import type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (data: FormData, key: string, value: unknown) => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n) => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T) =>\n    JSON.stringify(body, (key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n}) => {\n  if (value instanceof Date) {\n    return `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import type {\n  QuerySerializer,\n  QuerySerializerOptions,\n} from '@hey-api/client-core';\nimport {\n  getAuthToken,\n  jsonBodySerializer,\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '@hey-api/client-core';\n\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\ninterface PathSerializer {\n  path: Record<string, unknown>;\n  url: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style: ArraySeparatorStyle = 'simple';\n\n      if (name.endsWith('*')) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n\n      if (name.startsWith('.')) {\n        name = name.substring(1);\n        style = 'label';\n      } else if (name.startsWith(';')) {\n        name = name.substring(1);\n        style = 'matrix';\n      }\n\n      const value = path[name];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        url = url.replace(\n          match,\n          serializeArrayParam({ explode, name, style, value }),\n        );\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        url = url.replace(\n          match,\n          serializeObjectParam({\n            explode,\n            name,\n            style,\n            value: value as Record<string, unknown>,\n          }),\n        );\n        continue;\n      }\n\n      if (style === 'matrix') {\n        url = url.replace(\n          match,\n          `;${serializePrimitiveParam({\n            name,\n            value: value as string,\n          })}`,\n        );\n        continue;\n      }\n\n      const replaceValue = encodeURIComponent(\n        style === 'label' ? `.${value as string}` : (value as string),\n      );\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n  allowReserved,\n  array,\n  object,\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    let search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        if (Array.isArray(value)) {\n          search = [\n            ...search,\n            serializeArrayParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'form',\n              value,\n              ...array,\n            }),\n          ];\n          continue;\n        }\n\n        if (typeof value === 'object') {\n          search = [\n            ...search,\n            serializeObjectParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'deepObject',\n              value: value as Record<string, unknown>,\n              ...object,\n            }),\n          ];\n          continue;\n        }\n\n        search = [\n          ...search,\n          serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value as string,\n          }),\n        ];\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n\n    return;\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) => {\n  const url = getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n  return url;\n};\n\nexport const getUrl = ({\n  baseUrl,\n  path,\n  query,\n  querySerializer,\n  url: _url,\n}: {\n  baseUrl?: string;\n  path?: Record<string, unknown>;\n  query?: Record<string, unknown>;\n  querySerializer: QuerySerializer;\n  url: string;\n}) => {\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\n  let url = (baseUrl ?? '') + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({ path, url });\n  }\n  let search = query ? querySerializer(query) : '';\n  if (search.startsWith('?')) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += `?${search}`;\n  }\n  return url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header || typeof header !== 'object') {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers ? header.entries() : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  _fns: Interceptor[];\n\n  constructor() {\n    this._fns = [];\n  }\n\n  clear() {\n    this._fns = [];\n  }\n\n  exists(fn: Interceptor) {\n    return this._fns.indexOf(fn) !== -1;\n  }\n\n  eject(fn: Interceptor) {\n    const index = this._fns.indexOf(fn);\n    if (index !== -1) {\n      this._fns = [...this._fns.slice(0, index), ...this._fns.slice(index + 1)];\n    }\n  }\n\n  use(fn: Interceptor) {\n    this._fns = [...this._fns, fn];\n  }\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Pick<\n    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;\n  response: Pick<\n    Interceptors<ResInterceptor<Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import type { Client, Config, RequestOptions } from './types';\nimport {\n  buildUrl,\n  createConfig,\n  createInterceptors,\n  getParseAs,\n  mergeConfigs,\n  mergeHeaders,\n  setAuthParams,\n} from './utils';\n\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\n  body?: any;\n  headers: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n  let _config = mergeConfigs(createConfig(), config);\n\n  const getConfig = (): Config => ({ ..._config });\n\n  const setConfig = (config: Config): Config => {\n    _config = mergeConfigs(_config, config);\n    return getConfig();\n  };\n\n  const interceptors = createInterceptors<\n    Request,\n    Response,\n    unknown,\n    RequestOptions\n  >();\n\n  // @ts-expect-error\n  const request: Client['request'] = async (options) => {\n    const opts = {\n      ..._config,\n      ...options,\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n      headers: mergeHeaders(_config.headers, options.headers),\n    };\n\n    if (opts.security) {\n      await setAuthParams({\n        ...opts,\n        security: opts.security,\n      });\n    }\n\n    if (opts.body && opts.bodySerializer) {\n      opts.body = opts.bodySerializer(opts.body);\n    }\n\n    // remove Content-Type header if body is empty to avoid sending invalid requests\n    if (opts.body === undefined || opts.body === '') {\n      opts.headers.delete('Content-Type');\n    }\n\n    const url = buildUrl(opts);\n    const requestInit: ReqInit = {\n      redirect: 'follow',\n      ...opts,\n    };\n\n    let request = new Request(url, requestInit);\n\n    for (const fn of interceptors.request._fns) {\n      request = await fn(request, opts);\n    }\n\n    // fetch must be assigned here, otherwise it would throw the error:\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n    const _fetch = opts.fetch!;\n    let response = await _fetch(request);\n\n    for (const fn of interceptors.response._fns) {\n      response = await fn(response, request, opts);\n    }\n\n    const result = {\n      request,\n      response,\n    };\n\n    if (response.ok) {\n      if (\n        response.status === 204 ||\n        response.headers.get('Content-Length') === '0'\n      ) {\n        return {\n          data: {},\n          ...result,\n        };\n      }\n\n      const parseAs =\n        (opts.parseAs === 'auto'\n          ? getParseAs(response.headers.get('Content-Type'))\n          : opts.parseAs) ?? 'json';\n\n      if (parseAs === 'stream') {\n        return {\n          data: response.body,\n          ...result,\n        };\n      }\n\n      let data = await response[parseAs]();\n      if (parseAs === 'json') {\n        if (opts.responseValidator) {\n          await opts.responseValidator(data);\n        }\n\n        if (opts.responseTransformer) {\n          data = await opts.responseTransformer(data);\n        }\n      }\n\n      return {\n        data,\n        ...result,\n      };\n    }\n\n    let error = await response.text();\n\n    try {\n      error = JSON.parse(error);\n    } catch {\n      // noop\n    }\n\n    let finalError = error;\n\n    for (const fn of interceptors.error._fns) {\n      finalError = (await fn(error, response, request, opts)) as string;\n    }\n\n    finalError = finalError || ({} as string);\n\n    if (opts.throwOnError) {\n      throw finalError;\n    }\n\n    return {\n      error: finalError,\n      ...result,\n    };\n  };\n\n  return {\n    buildUrl,\n    connect: (options) => request({ ...options, method: 'CONNECT' }),\n    delete: (options) => request({ ...options, method: 'DELETE' }),\n    get: (options) => request({ ...options, method: 'GET' }),\n    getConfig,\n    head: (options) => request({ ...options, method: 'HEAD' }),\n    interceptors,\n    options: (options) => request({ ...options, method: 'OPTIONS' }),\n    patch: (options) => request({ ...options, method: 'PATCH' }),\n    post: (options) => request({ ...options, method: 'POST' }),\n    put: (options) => request({ ...options, method: 'PUT' }),\n    request,\n    setConfig,\n    trace: (options) => request({ ...options, method: 'TRACE' }),\n  };\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from './types.gen';\nimport { type Config, type ClientOptions as DefaultClientOptions, createClient, createConfig } from '@hey-api/client-fetch';\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(createConfig<ClientOptions>({\n    baseUrl: 'http://localhost:8000',\n    throwOnError: true\n}));","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';\nimport type { GetUserIdentityData, GetUserIdentityResponse2, GetUserIdentityError, GetCollectionByCrnData, GetCollectionByCrnResponse, GetCollectionByCrnError, HealthcheckData, HealthcheckResponse, HealthcheckError, HeartbeatData, HeartbeatResponse2, HeartbeatError, PreFlightChecksData, PreFlightChecksResponse, PreFlightChecksError, ResetData, ResetResponse, ResetError, CreateTenantData, CreateTenantResponse2, CreateTenantError, GetTenantData, GetTenantResponse2, GetTenantError, UpdateTenantData, UpdateTenantResponse2, UpdateTenantError, ListDatabasesData, ListDatabasesResponse, ListDatabasesError, CreateDatabaseData, CreateDatabaseResponse2, CreateDatabaseError, DeleteDatabaseData, DeleteDatabaseResponse2, DeleteDatabaseError, GetDatabaseData, GetDatabaseResponse, GetDatabaseError, ListCollectionsData, ListCollectionsResponse, ListCollectionsError, CreateCollectionData, CreateCollectionResponse, CreateCollectionError, DeleteCollectionData, DeleteCollectionResponse, DeleteCollectionError, GetCollectionData, GetCollectionResponse, GetCollectionError, UpdateCollectionData, UpdateCollectionResponse2, UpdateCollectionError, CollectionAddData, CollectionAddResponse, DetachFunctionData, DetachFunctionResponse2, DetachFunctionError, CollectionCountData, CollectionCountResponse, CollectionCountError, CollectionDeleteData, CollectionDeleteResponse, CollectionDeleteError, ForkCollectionData, ForkCollectionResponse, ForkCollectionError, AttachFunctionData, AttachFunctionResponse2, AttachFunctionError, GetAttachedFunctionData, GetAttachedFunctionResponse2, GetAttachedFunctionError, CollectionGetData, CollectionGetResponse, CollectionGetError, IndexingStatusData, IndexingStatusResponse, IndexingStatusError, CollectionQueryData, CollectionQueryResponse, CollectionQueryError, CollectionSearchData, CollectionSearchResponse, CollectionSearchError, CollectionUpdateData, CollectionUpdateResponse, CollectionUpsertData, CollectionUpsertResponse, CollectionUpsertError, CountCollectionsData, CountCollectionsResponse, CountCollectionsError, VersionData, VersionResponse } from './types.gen';\nimport { client as _heyApiClient } from './client.gen';\n\nexport type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {\n    /**\n     * You can provide a client instance returned by `createClient()` instead of\n     * individual options. This might be also useful if you want to implement a\n     * custom client.\n     */\n    client?: Client;\n    /**\n     * You can pass arbitrary values through the `meta` object. This can be\n     * used to access values that aren't defined as part of the SDK function.\n     */\n    meta?: Record<string, unknown>;\n};\n\nexport class DefaultService {\n    /**\n     * Retrieves the current user's identity, tenant, and databases.\n     */\n    public static getUserIdentity<ThrowOnError extends boolean = true>(options?: Options<GetUserIdentityData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<GetUserIdentityResponse2, GetUserIdentityError, ThrowOnError>({\n            url: '/api/v2/auth/identity',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a collection by Chroma Resource Name.\n     */\n    public static getCollectionByCrn<ThrowOnError extends boolean = true>(options: Options<GetCollectionByCrnData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetCollectionByCrnResponse, GetCollectionByCrnError, ThrowOnError>({\n            url: '/api/v2/collections/{crn}',\n            ...options\n        });\n    }\n    \n    /**\n     * Health check endpoint that returns 200 if the server and executor are ready\n     */\n    public static healthcheck<ThrowOnError extends boolean = true>(options?: Options<HealthcheckData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<HealthcheckResponse, HealthcheckError, ThrowOnError>({\n            url: '/api/v2/healthcheck',\n            ...options\n        });\n    }\n    \n    /**\n     * Heartbeat endpoint that returns a nanosecond timestamp of the current time.\n     */\n    public static heartbeat<ThrowOnError extends boolean = true>(options?: Options<HeartbeatData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<HeartbeatResponse2, HeartbeatError, ThrowOnError>({\n            url: '/api/v2/heartbeat',\n            ...options\n        });\n    }\n    \n    /**\n     * Pre-flight checks endpoint reporting basic readiness info.\n     */\n    public static preFlightChecks<ThrowOnError extends boolean = true>(options?: Options<PreFlightChecksData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<PreFlightChecksResponse, PreFlightChecksError, ThrowOnError>({\n            url: '/api/v2/pre-flight-checks',\n            ...options\n        });\n    }\n    \n    /**\n     * Reset endpoint allowing authorized users to reset the database.\n     */\n    public static reset<ThrowOnError extends boolean = true>(options?: Options<ResetData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).post<ResetResponse, ResetError, ThrowOnError>({\n            url: '/api/v2/reset',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new tenant.\n     */\n    public static createTenant<ThrowOnError extends boolean = true>(options: Options<CreateTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateTenantResponse2, CreateTenantError, ThrowOnError>({\n            url: '/api/v2/tenants',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Returns an existing tenant by name.\n     */\n    public static getTenant<ThrowOnError extends boolean = true>(options: Options<GetTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetTenantResponse2, GetTenantError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant_name}',\n            ...options\n        });\n    }\n    \n    /**\n     * Updates an existing tenant by name.\n     */\n    public static updateTenant<ThrowOnError extends boolean = true>(options: Options<UpdateTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).patch<UpdateTenantResponse2, UpdateTenantError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant_name}',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Lists all databases for a given tenant.\n     */\n    public static listDatabases<ThrowOnError extends boolean = true>(options: Options<ListDatabasesData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<ListDatabasesResponse, ListDatabasesError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new database for a given tenant.\n     */\n    public static createDatabase<ThrowOnError extends boolean = true>(options: Options<CreateDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateDatabaseResponse2, CreateDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Deletes a specific database.\n     */\n    public static deleteDatabase<ThrowOnError extends boolean = true>(options: Options<DeleteDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).delete<DeleteDatabaseResponse2, DeleteDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a specific database by name.\n     */\n    public static getDatabase<ThrowOnError extends boolean = true>(options: Options<GetDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetDatabaseResponse, GetDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}',\n            ...options\n        });\n    }\n    \n    /**\n     * Lists all collections in the specified database.\n     */\n    public static listCollections<ThrowOnError extends boolean = true>(options: Options<ListCollectionsData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<ListCollectionsResponse, ListCollectionsError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new collection under the specified database.\n     */\n    public static createCollection<ThrowOnError extends boolean = true>(options: Options<CreateCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateCollectionResponse, CreateCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Deletes a collection in a given database.\n     */\n    public static deleteCollection<ThrowOnError extends boolean = true>(options: Options<DeleteCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).delete<DeleteCollectionResponse, DeleteCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a collection by ID or name.\n     */\n    public static getCollection<ThrowOnError extends boolean = true>(options: Options<GetCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetCollectionResponse, GetCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options\n        });\n    }\n    \n    /**\n     * Updates an existing collection's name or metadata.\n     */\n    public static updateCollection<ThrowOnError extends boolean = true>(options: Options<UpdateCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).put<UpdateCollectionResponse2, UpdateCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Adds records to a collection.\n     */\n    public static collectionAdd<ThrowOnError extends boolean = true>(options: Options<CollectionAddData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionAddResponse, unknown, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Detach a function\n     */\n    public static detachFunction<ThrowOnError extends boolean = true>(options: Options<DetachFunctionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<DetachFunctionResponse2, DetachFunctionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/attached_functions/{name}/detach',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves the number of records in a collection.\n     */\n    public static collectionCount<ThrowOnError extends boolean = true>(options: Options<CollectionCountData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<CollectionCountResponse, CollectionCountError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count',\n            ...options\n        });\n    }\n    \n    /**\n     * Deletes records in a collection. Can filter by IDs or metadata.\n     */\n    public static collectionDelete<ThrowOnError extends boolean = true>(options: Options<CollectionDeleteData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionDeleteResponse, CollectionDeleteError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Forks an existing collection.\n     */\n    public static forkCollection<ThrowOnError extends boolean = true>(options: Options<ForkCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<ForkCollectionResponse, ForkCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Attach a function to a collection\n     */\n    public static attachFunction<ThrowOnError extends boolean = true>(options: Options<AttachFunctionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<AttachFunctionResponse2, AttachFunctionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/attach',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Get an attached function by name\n     */\n    public static getAttachedFunction<ThrowOnError extends boolean = true>(options: Options<GetAttachedFunctionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetAttachedFunctionResponse2, GetAttachedFunctionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/{function_name}',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves records from a collection by ID or metadata filter.\n     */\n    public static collectionGet<ThrowOnError extends boolean = true>(options: Options<CollectionGetData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionGetResponse, CollectionGetError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves the indexing status of a collection.\n     */\n    public static indexingStatus<ThrowOnError extends boolean = true>(options: Options<IndexingStatusData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<IndexingStatusResponse, IndexingStatusError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/indexing_status',\n            ...options\n        });\n    }\n    \n    /**\n     * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search\n     */\n    public static collectionQuery<ThrowOnError extends boolean = true>(options: Options<CollectionQueryData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionQueryResponse, CollectionQueryError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Search records from a collection with hybrid criterias.\n     */\n    public static collectionSearch<ThrowOnError extends boolean = true>(options: Options<CollectionSearchData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionSearchResponse, CollectionSearchError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Updates records in a collection by ID.\n     */\n    public static collectionUpdate<ThrowOnError extends boolean = true>(options: Options<CollectionUpdateData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionUpdateResponse, unknown, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Upserts records in a collection (create if not exists, otherwise update).\n     */\n    public static collectionUpsert<ThrowOnError extends boolean = true>(options: Options<CollectionUpsertData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionUpsertResponse, CollectionUpsertError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves the total number of collections in a given database.\n     */\n    public static countCollections<ThrowOnError extends boolean = true>(options: Options<CountCollectionsData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<CountCollectionsResponse, CountCollectionsError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections_count',\n            ...options\n        });\n    }\n    \n    /**\n     * Returns the version of the server.\n     */\n    public static version<ThrowOnError extends boolean = true>(options?: Options<VersionData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<VersionResponse, unknown, ThrowOnError>({\n            url: '/api/v2/version',\n            ...options\n        });\n    }\n    \n}","/**\n * This is a generic Chroma error.\n */\nexport class ChromaError extends Error {\n  constructor(name: string, message: string, public readonly cause?: unknown) {\n    super(message);\n    this.name = name;\n  }\n}\n\n/**\n * Indicates that there was a problem with the connection to the Chroma server (e.g. the server is down or the client is not connected to the internet)\n */\nexport class ChromaConnectionError extends Error {\n  name = \"ChromaConnectionError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** Indicates that the server encountered an error while handling the request. */\nexport class ChromaServerError extends Error {\n  name = \"ChromaServerError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** Indicate that there was an issue with the request that the client made. */\nexport class ChromaClientError extends Error {\n  name = \"ChromaClientError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** The request lacked valid authentication. */\nexport class ChromaUnauthorizedError extends Error {\n  name = \"ChromaAuthError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** The user does not have permission to access the requested resource. */\nexport class ChromaForbiddenError extends Error {\n  name = \"ChromaForbiddenError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaNotFoundError extends Error {\n  name = \"ChromaNotFoundError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaValueError extends Error {\n  name = \"ChromaValueError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class InvalidCollectionError extends Error {\n  name = \"InvalidCollectionError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class InvalidArgumentError extends Error {\n  name = \"InvalidArgumentError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaUniqueError extends Error {\n  name = \"ChromaUniqueError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaQuotaExceededError extends Error {\n  name = \"ChromaQuotaExceededError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaRateLimitError extends Error {\n  name = \"ChromaRateLimitError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport function createErrorByType(type: string, message: string) {\n  switch (type) {\n    case \"InvalidCollection\":\n      return new InvalidCollectionError(message);\n    case \"InvalidArgumentError\":\n      return new InvalidArgumentError(message);\n    default:\n      return undefined;\n  }\n}\n","import { AdminClientArgs } from \"./admin-client\";\nimport { ChromaClientArgs } from \"./chroma-client\";\nimport {\n  BaseRecordSet,\n  IncludeEnum,\n  Metadata,\n  RecordSet,\n  recordSetFields,\n  Where,\n  WhereDocument,\n} from \"./types\";\nimport { Include, SparseVector } from \"./api\";\nimport { ChromaValueError } from \"./errors\";\n\n/** Default tenant name used when none is specified */\nexport const DEFAULT_TENANT = \"default_tenant\";\n/** Default database name used when none is specified */\nexport const DEFAULT_DATABASE = \"default_database\";\n\n/** Default configuration for AdminClient connections */\nexport const defaultAdminClientArgs: AdminClientArgs = {\n  host: \"localhost\",\n  port: 8000,\n  ssl: false,\n};\n\n/** Default configuration for ChromaClient connections */\nexport const defaultChromaClientArgs: ChromaClientArgs = {\n  ...defaultAdminClientArgs,\n  tenant: DEFAULT_TENANT,\n  database: DEFAULT_DATABASE,\n};\n\n/**\n * Supported HTTP methods for API requests.\n */\nexport type HttpMethod =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"HEAD\"\n  | \"CONNECT\"\n  | \"OPTIONS\"\n  | \"PATCH\"\n  | \"TRACE\"\n  | undefined;\n\n/**\n * Normalizes HTTP method strings to standard uppercase format.\n * @param method - HTTP method string to normalize\n * @returns Normalized HttpMethod or undefined if invalid\n */\nexport const normalizeMethod = (method?: string): HttpMethod => {\n  if (method) {\n    switch (method.toUpperCase()) {\n      case \"GET\":\n        return \"GET\";\n      case \"POST\":\n        return \"POST\";\n      case \"PUT\":\n        return \"PUT\";\n      case \"DELETE\":\n        return \"DELETE\";\n      case \"HEAD\":\n        return \"HEAD\";\n      case \"CONNECT\":\n        return \"CONNECT\";\n      case \"OPTIONS\":\n        return \"OPTIONS\";\n      case \"PATCH\":\n        return \"PATCH\";\n      case \"TRACE\":\n        return \"TRACE\";\n      default:\n        return undefined;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Validates that all arrays in a RecordSet have consistent lengths.\n * @param recordSet - The record set to validate\n * @throws ChromaValueError if arrays have inconsistent lengths or are empty\n */\nexport const validateRecordSetLengthConsistency = (recordSet: RecordSet) => {\n  const lengths: [string, number][] = Object.entries(recordSet)\n    .filter(\n      ([field, value]) =>\n        recordSetFields.includes(field) && value !== undefined,\n    )\n    .map(([field, value]) => [field, value.length]);\n\n  if (lengths.length === 0) {\n    throw new ChromaValueError(\n      `At least one of ${recordSetFields.join(\", \")} must be provided`,\n    );\n  }\n\n  const zeroLength = lengths\n    .filter(([_, length]) => length === 0)\n    .map(([field, _]) => field);\n  if (zeroLength.length > 0) {\n    throw new ChromaValueError(\n      `Non-empty lists are required for ${zeroLength.join(\", \")}`,\n    );\n  }\n\n  if (new Set(lengths.map(([_, length]) => length)).size > 1) {\n    throw new ChromaValueError(\n      `Unequal lengths for fields ${lengths\n        .map(([field, _]) => field)\n        .join(\", \")}`,\n    );\n  }\n};\n\nconst validateEmbeddings = ({\n  embeddings,\n  fieldName = \"embeddings\",\n}: {\n  embeddings: number[][];\n  fieldName: string;\n}) => {\n  if (!Array.isArray(embeddings)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof embeddings}`,\n    );\n  }\n\n  if (embeddings.length === 0) {\n    throw new ChromaValueError(\n      \"Expected embeddings to be an array with at least one item\",\n    );\n  }\n\n  if (!embeddings.filter((e) => e.every((n: any) => typeof n === \"number\"))) {\n    throw new ChromaValueError(\n      \"Expected each embedding to be an array of numbers\",\n    );\n  }\n\n  embeddings.forEach((embedding, i) => {\n    if (embedding.length === 0) {\n      throw new ChromaValueError(\n        `Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`,\n      );\n    }\n  });\n};\n\nconst validateDocuments = ({\n  documents,\n  nullable = false,\n  fieldName = \"documents\",\n}: {\n  documents: (string | null | undefined)[];\n  fieldName: string;\n  nullable?: boolean;\n}) => {\n  if (!Array.isArray(documents)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof documents}`,\n    );\n  }\n\n  if (documents.length === 0) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be a non-empty list`,\n    );\n  }\n\n  documents.forEach((document) => {\n    if (!nullable && typeof document !== \"string\" && !document) {\n      throw new ChromaValueError(\n        `Expected each document to be a string, but got ${typeof document}`,\n      );\n    }\n  });\n};\n\n/**\n * Validates an array of IDs for type correctness and uniqueness.\n * @param ids - Array of ID strings to validate\n * @throws ChromaValueError if IDs are not strings, empty, or contain duplicates\n */\nexport const validateIDs = (ids: string[]) => {\n  if (!Array.isArray(ids)) {\n    throw new ChromaValueError(\n      `Expected 'ids' to be an array, but got ${typeof ids}`,\n    );\n  }\n\n  if (ids.length === 0) {\n    throw new ChromaValueError(\"Expected 'ids' to be a non-empty list\");\n  }\n\n  const nonStrings = ids\n    .map((id, i) => [id, i] as [any, number])\n    .filter(([id, _]) => typeof id !== \"string\")\n    .map(([_, i]) => i);\n\n  if (nonStrings.length > 0) {\n    throw new ChromaValueError(\n      `Found non-string IDs at ${nonStrings.join(\", \")}`,\n    );\n  }\n\n  const seen = new Set();\n  const duplicates = ids.filter((id) => {\n    if (seen.has(id)) {\n      return id;\n    }\n    seen.add(id);\n  });\n  let message = \"Expected IDs to be unique, but found duplicates of\";\n  if (duplicates.length > 0 && duplicates.length <= 5) {\n    throw new ChromaValueError(`${message} ${duplicates.join(\", \")}`);\n  }\n  if (duplicates.length > 0) {\n    throw new ChromaValueError(\n      `${message} ${duplicates.slice(0, 5).join(\", \")}, ..., ${duplicates\n        .slice(duplicates.length - 5)\n        .join(\", \")}`,\n    );\n  }\n};\n\nexport const validateSparseVector = (v: unknown): v is SparseVector => {\n  if (typeof v !== \"object\" || v === null) {\n    return false;\n  }\n\n  const candidate = v as Record<string, unknown>;\n  const indices = candidate.indices;\n  const values = candidate.values;\n\n  if (!Array.isArray(indices) || !Array.isArray(values)) {\n    return false;\n  }\n\n  return (\n    indices.every((e) => typeof e === \"number\") &&\n    values.every((e) => typeof e === \"number\")\n  );\n};\n\n/**\n * Validates metadata object for correct types and non-emptiness.\n * @param metadata - Metadata object to validate\n * @throws ChromaValueError if metadata is invalid\n */\nexport const validateMetadata = (metadata?: Metadata) => {\n  if (!metadata) {\n    return;\n  }\n\n  if (Object.keys(metadata).length === 0) {\n    throw new ChromaValueError(\"Expected metadata to be non-empty\");\n  }\n\n  if (\n    !Object.values(metadata).every(\n      (v: any) =>\n        v === null ||\n        v === undefined ||\n        typeof v === \"string\" ||\n        typeof v === \"number\" ||\n        typeof v === \"boolean\" ||\n        validateSparseVector(v),\n    )\n  ) {\n    throw new ChromaValueError(\n      \"Expected metadata to be a string, number, boolean, SparseVector, or nullable\",\n    );\n  }\n};\n\nconst SPARSE_VECTOR_TYPE = \"sparse_vector\" as const;\n\ntype SerializedSparseVector = SparseVector & {\n  \"#type\": typeof SPARSE_VECTOR_TYPE;\n};\n\ntype SerializedMetadataValue =\n  | boolean\n  | number\n  | string\n  | SerializedSparseVector\n  | SparseVector\n  | null;\n\nexport type SerializedMetadata = Record<string, SerializedMetadataValue>;\n\nconst toSerializedSparseVector = (\n  vector: SparseVector,\n): SerializedSparseVector => ({\n  \"#type\": SPARSE_VECTOR_TYPE,\n  indices: vector.indices,\n  values: vector.values,\n});\n\nexport const serializeMetadata = (\n  metadata?: Metadata | null,\n): SerializedMetadata | null | undefined => {\n  if (metadata === undefined) {\n    return undefined;\n  }\n\n  if (metadata === null) {\n    return null;\n  }\n\n  const result: SerializedMetadata = {};\n\n  Object.entries(metadata).forEach(([key, value]) => {\n    if (validateSparseVector(value)) {\n      result[key] = toSerializedSparseVector(value);\n    } else {\n      result[key] = value ?? null;\n    }\n  });\n\n  return result;\n};\n\nexport const serializeMetadatas = (\n  metadatas?: Metadata[] | null,\n): (SerializedMetadata | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadata) => serializeMetadata(metadata) ?? null);\n};\n\nconst isSerializedSparseVector = (\n  value: unknown,\n): value is SerializedSparseVector => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  const candidate = value as Record<string, unknown>;\n  if (candidate[\"#type\"] !== SPARSE_VECTOR_TYPE) {\n    return false;\n  }\n\n  return validateSparseVector(candidate);\n};\n\nconst deserializeMetadataValue = (\n  value: SerializedMetadataValue | undefined,\n): Metadata[keyof Metadata] | null => {\n  if (isSerializedSparseVector(value)) {\n    return {\n      indices: value.indices,\n      values: value.values,\n    };\n  }\n\n  return value as Metadata[keyof Metadata] | null;\n};\n\nexport const deserializeMetadata = (\n  metadata?: SerializedMetadata | null,\n): Metadata | null | undefined => {\n  if (metadata === undefined) {\n    return undefined;\n  }\n\n  if (metadata === null) {\n    return null;\n  }\n\n  const result: Metadata = {};\n\n  Object.entries(metadata).forEach(([key, value]) => {\n    result[key] = deserializeMetadataValue(value);\n  });\n\n  return result;\n};\n\nexport const deserializeMetadatas = (\n  metadatas?: (SerializedMetadata | null)[] | null,\n): (Metadata | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadata) => deserializeMetadata(metadata) ?? null);\n};\n\nexport const deserializeMetadataMatrix = (\n  metadatas?: (Array<SerializedMetadata | null> | null)[] | null,\n): (Array<Metadata | null> | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadataArray) => {\n    if (metadataArray === null) {\n      return null;\n    }\n\n    const deserialized = deserializeMetadatas(metadataArray);\n    return deserialized ?? [];\n  });\n};\n\nconst validateMetadatas = (metadatas: Metadata[]) => {\n  if (!Array.isArray(metadatas)) {\n    throw new ChromaValueError(\n      `Expected metadatas to be an array, but got ${typeof metadatas}`,\n    );\n  }\n\n  metadatas.forEach((metadata) => validateMetadata(metadata));\n};\n\n/**\n * Validates a base record set for required fields and data consistency.\n * @param options - Validation options\n * @param options.recordSet - The record set to validate\n * @param options.update - Whether this is for an update operation (relaxes requirements)\n * @param options.embeddingsField - Name of the embeddings field for error messages\n * @param options.documentsField - Name of the documents field for error messages\n * @throws ChromaValueError if validation fails\n */\nexport const validateBaseRecordSet = ({\n  recordSet,\n  update = false,\n  embeddingsField = \"embeddings\",\n  documentsField = \"documents\",\n}: {\n  recordSet: BaseRecordSet;\n  update?: boolean;\n  embeddingsField?: string;\n  documentsField?: string;\n}) => {\n  if (!recordSet.embeddings && !recordSet.documents && !update) {\n    throw new ChromaValueError(\n      `At least one of '${embeddingsField}' and '${documentsField}' must be provided`,\n    );\n  }\n\n  if (recordSet.embeddings) {\n    validateEmbeddings({\n      embeddings: recordSet.embeddings,\n      fieldName: embeddingsField,\n    });\n  }\n\n  if (recordSet.documents) {\n    validateDocuments({\n      documents: recordSet.documents,\n      fieldName: documentsField,\n    });\n  }\n\n  if (recordSet.metadatas) {\n    validateMetadatas(recordSet.metadatas);\n  }\n};\n\nexport const validateMaxBatchSize = (\n  recordSetLength: number,\n  maxBatchSize: number,\n) => {\n  if (recordSetLength > maxBatchSize) {\n    throw new ChromaValueError(\n      `Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`,\n    );\n  }\n};\n\n/**\n * Validates a where clause for metadata filtering.\n * @param where - Where clause object to validate\n * @throws ChromaValueError if the where clause is malformed\n */\nexport const validateWhere = (where: Where) => {\n  if (typeof where !== \"object\") {\n    throw new ChromaValueError(\"Expected where to be a non-empty object\");\n  }\n\n  if (Object.keys(where).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'where' to have exactly one operator, but got ${\n        Object.keys(where).length\n      }`,\n    );\n  }\n\n  Object.entries(where).forEach(([key, value]) => {\n    if (\n      key !== \"$and\" &&\n      key !== \"$or\" &&\n      key !== \"$in\" &&\n      key !== \"$nin\" &&\n      ![\"string\", \"number\", \"boolean\", \"object\"].includes(typeof value)\n    ) {\n      throw new ChromaValueError(\n        `Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`,\n      );\n    }\n\n    if (key === \"$and\" || key === \"$or\") {\n      if (Object.keys(value).length <= 1) {\n        throw new ChromaValueError(\n          `Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`,\n        );\n      }\n\n      value.forEach((w: Where) => validateWhere(w));\n      return;\n    }\n\n    if (typeof value === \"object\") {\n      if (Object.keys(value).length != 1) {\n        throw new ChromaValueError(\n          `Expected operator expression to have one operator, but got ${value}`,\n        );\n      }\n\n      const [operator, operand] = Object.entries(value)[0];\n\n      if (\n        [\"$gt\", \"$gte\", \"$lt\", \"$lte\"].includes(operator) &&\n        typeof operand !== \"number\"\n      ) {\n        throw new ChromaValueError(\n          `Expected operand value to be a number for ${operator}, but got ${typeof operand}`,\n        );\n      }\n\n      if ([\"$in\", \"$nin\"].includes(operator) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          `Expected operand value to be an array for ${operator}, but got ${operand}`,\n        );\n      }\n\n      if (\n        ![\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"$eq\", \"$in\", \"$nin\"].includes(\n          operator,\n        )\n      ) {\n        throw new ChromaValueError(\n          `Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`,\n        );\n      }\n\n      if (\n        ![\"string\", \"number\", \"boolean\"].includes(typeof operand) &&\n        !Array.isArray(operand)\n      ) {\n        throw new ChromaValueError(\n          \"Expected operand value to be a string, number, boolean, or a list of those types\",\n        );\n      }\n\n      if (\n        Array.isArray(operand) &&\n        (operand.length === 0 ||\n          !operand.every((item) => typeof item === typeof operand[0]))\n      ) {\n        throw new ChromaValueError(\n          \"Expected 'where' operand value to be a non-empty list and all values to be of the same type\",\n        );\n      }\n    }\n  });\n};\n\n/**\n * Validates a where document clause for document content filtering.\n * @param whereDocument - Where document clause to validate\n * @throws ChromaValueError if the clause is malformed\n */\nexport const validateWhereDocument = (whereDocument: WhereDocument) => {\n  if (typeof whereDocument !== \"object\") {\n    throw new ChromaValueError(\n      \"Expected 'whereDocument' to be a non-empty object\",\n    );\n  }\n\n  if (Object.keys(whereDocument).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`,\n    );\n  }\n\n  const [operator, operand] = Object.entries(whereDocument)[0];\n  if (\n    ![\n      \"$contains\",\n      \"$not_contains\",\n      \"$matches\",\n      \"$not_matches\",\n      \"$regex\",\n      \"$not_regex\",\n      \"$and\",\n      \"$or\",\n    ].includes(operator)\n  ) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`,\n    );\n  }\n\n  if (operator === \"$and\" || operator === \"$or\") {\n    if (!Array.isArray(operand)) {\n      throw new ChromaValueError(\n        `Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`,\n      );\n    }\n\n    if (operand.length <= 1) {\n      throw new ChromaValueError(\n        `Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`,\n      );\n    }\n\n    operand.forEach((item) => validateWhereDocument(item));\n  }\n\n  if (\n    (operand === \"$contains\" ||\n      operand === \"$not_contains\" ||\n      operand === \"$regex\" ||\n      operand === \"$not_regex\") &&\n    (typeof (operator as any) !== \"string\" || operator.length === 0)\n  ) {\n    throw new ChromaValueError(\n      `Expected operand for ${operator} to be a non empty string, but got ${operand}`,\n    );\n  }\n};\n\n/**\n * Validates include fields for query operations.\n * @param options - Validation options\n * @param options.include - Array of fields to include in results\n * @param options.exclude - Optional array of fields that should not be included\n * @throws ChromaValueError if include fields are invalid\n */\nexport const validateInclude = ({\n  include,\n  exclude,\n}: {\n  include: Include[];\n  exclude?: Include[];\n}) => {\n  if (!Array.isArray(include)) {\n    throw new ChromaValueError(\"Expected 'include' to be a non-empty array\");\n  }\n\n  const validValues = Object.keys(IncludeEnum);\n  include.forEach((item) => {\n    if (typeof (item as any) !== \"string\") {\n      throw new ChromaValueError(\"Expected 'include' items to be strings\");\n    }\n\n    if (!validValues.includes(item)) {\n      throw new ChromaValueError(\n        `Expected 'include' items to be one of ${validValues.join(\n          \", \",\n        )}, but got ${item}`,\n      );\n    }\n\n    if (exclude?.includes(item)) {\n      throw new ChromaValueError(`${item} is not allowed for this operation`);\n    }\n  });\n};\n\n/**\n * Validates the number of results parameter for queries.\n * @param nResults - Number of results to validate\n * @throws ChromaValueError if nResults is not a positive number\n */\nexport const validateNResults = (nResults: number) => {\n  if (typeof (nResults as any) !== \"number\") {\n    throw new ChromaValueError(\n      `Expected 'nResults' to be a number, but got ${typeof nResults}`,\n    );\n  }\n\n  if (nResults <= 0) {\n    throw new ChromaValueError(\"Number of requested results has to positive\");\n  }\n};\n\nexport const parseConnectionPath = (path: string) => {\n  try {\n    const url = new URL(path);\n\n    const ssl = url.protocol === \"https:\";\n    const host = url.hostname;\n    const port = url.port;\n\n    return {\n      ssl,\n      host,\n      port: Number(port),\n    };\n  } catch {\n    throw new ChromaValueError(`Invalid URL: ${path}`);\n  }\n};\nconst packEmbedding = (embedding: number[]): ArrayBuffer => {\n  const buffer = new ArrayBuffer(embedding.length * 4);\n  const view = new Float32Array(buffer);\n  for (let i = 0; i < embedding.length; i++) {\n    view[i] = embedding[i];\n  }\n  return buffer;\n};\n\nexport const embeddingsToBase64Bytes = (embeddings: number[][]) => {\n  return embeddings.map((embedding) => {\n    const buffer = packEmbedding(embedding);\n\n    const uint8Array = new Uint8Array(buffer);\n    const binaryString = Array.from(uint8Array, (byte) =>\n      String.fromCharCode(byte),\n    ).join(\"\");\n    return btoa(binaryString);\n  });\n};\n","import { EmbeddingFunctionConfiguration, SparseVector } from \"./api\";\nimport { ChromaValueError } from \"./errors\";\nimport { DefaultEmbeddingFunction } from \"@chroma-core/default-embed\";\nimport { ChromaClient } from \"./chroma-client\";\n\n/**\n * Supported vector space types.\n */\nexport type EmbeddingFunctionSpace = \"cosine\" | \"l2\" | \"ip\";\n\n/**\n * Interface for embedding functions.\n * Embedding functions transform text documents into numerical representations\n * that can be used for similarity search and other vector operations.\n */\nexport interface EmbeddingFunction {\n  /**\n   * Generates embeddings for the given texts.\n   * @param texts - Array of text strings to embed\n   * @returns Promise resolving to array of embedding vectors\n   */\n  generate(texts: string[]): Promise<number[][]>;\n  /**\n   * Generates embeddings specifically for query texts.\n   * The client will fall back to using the implementation of `generate`\n   * if this function is not provided.\n   * @param texts - Array of query text strings to embed\n   * @returns Promise resolving to array of embedding vectors\n   */\n  generateForQueries?(texts: string[]): Promise<number[][]>;\n  /** Optional name identifier for the embedding function */\n  name?: string;\n  /** Returns the default vector space for this embedding function */\n  defaultSpace?(): EmbeddingFunctionSpace;\n  /** Returns all supported vector spaces for this embedding function */\n  supportedSpaces?(): EmbeddingFunctionSpace[];\n  /** Creates an instance from configuration object */\n  buildFromConfig?(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): EmbeddingFunction;\n  /** Returns the current configuration as an object */\n  getConfig?(): Record<string, any>;\n  /**\n   * Validates that a configuration update is allowed.\n   * @param newConfig - New configuration to validate\n   */\n  validateConfigUpdate?(newConfig: Record<string, any>): void;\n  /**\n   * Validates that a configuration object is valid.\n   * @param config - Configuration to validate\n   */\n  validateConfig?(config: Record<string, any>): void;\n}\n\n/**\n * Interface for sparse embedding functions.\n * Sparse embedding functions transform text documents into sparse numerical representations\n * where only non-zero values are stored, making them efficient for high-dimensional spaces.\n */\nexport interface SparseEmbeddingFunction {\n  /**\n   * Generates sparse embeddings for the given texts.\n   * @param texts - Array of text strings to embed\n   * @returns Promise resolving to array of sparse vectors\n   */\n  generate(texts: string[]): Promise<SparseVector[]>;\n  /**\n   * Generates sparse embeddings specifically for query texts.\n   * The client will fall back to using the implementation of `generate`\n   * if this function is not provided.\n   * @param texts - Array of query text strings to embed\n   * @returns Promise resolving to array of sparse vectors\n   */\n  generateForQueries?(texts: string[]): Promise<SparseVector[]>;\n  /** Optional name identifier for the embedding function */\n  name?: string;\n  /** Creates an instance from configuration object */\n  buildFromConfig?(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): SparseEmbeddingFunction;\n  /** Returns the current configuration as an object */\n  getConfig?(): Record<string, any>;\n  /**\n   * Validates that a configuration update is allowed.\n   * @param newConfig - New configuration to validate\n   */\n  validateConfigUpdate?(newConfig: Record<string, any>): void;\n  /**\n   * Validates that a configuration object is valid.\n   * @param config - Configuration to validate\n   */\n  validateConfig?(config: Record<string, any>): void;\n}\n\n/**\n * Interface for embedding function constructor classes.\n * Used for registering and instantiating embedding functions.\n */\nexport interface EmbeddingFunctionClass {\n  /** Constructor for creating new instances */\n  new (...args: any[]): EmbeddingFunction;\n  /** Name identifier for the embedding function */\n  name: string;\n  /** Static method to build instance from configuration */\n  buildFromConfig(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): EmbeddingFunction;\n}\n\n/**\n * Interface for sparse embedding function constructor classes.\n * Used for registering and instantiating sparse embedding functions.\n */\nexport interface SparseEmbeddingFunctionClass {\n  /** Constructor for creating new instances */\n  new (...args: any[]): SparseEmbeddingFunction;\n  /** Name identifier for the embedding function */\n  name: string;\n  /** Static method to build instance from configuration */\n  buildFromConfig(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): SparseEmbeddingFunction;\n}\n\n/**\n * Registry of available embedding functions.\n * Maps function names to their constructor classes.\n */\nexport const knownEmbeddingFunctions = new Map<\n  string,\n  EmbeddingFunctionClass\n>();\n\nconst pythonEmbeddingFunctions: Record<string, string> = {\n  onnx_mini_lm_l6_v2: \"default-embed\",\n  default: \"default-embed\",\n  together_ai: \"together-ai\",\n  sentence_transformer: \"sentence-transformer\",\n};\n\nconst unsupportedEmbeddingFunctions: Set<string> = new Set([\n  \"amazon_bedrock\",\n  \"baseten\",\n  \"langchain\",\n  \"google_palm\",\n  \"huggingface\",\n  \"instructor\",\n  \"open_clip\",\n  \"roboflow\",\n  \"text2vec\",\n]);\n\nconst chromaCloudEmbeddingFunctions: Set<string> = new Set([\n  \"chroma-cloud-splade\",\n  \"chroma-cloud-qwen\",\n]);\n\n/**\n * Registry of available sparse embedding functions.\n * Maps function names to their constructor classes.\n */\nexport const knownSparseEmbeddingFunctions = new Map<\n  string,\n  SparseEmbeddingFunctionClass\n>();\n\nconst pythonSparseEmbeddingFunctions: Record<string, string> = {\n  chroma_bm25: \"chroma-bm25\",\n};\n\nconst unsupportedSparseEmbeddingFunctions: Set<string> = new Set([\n  \"bm25\",\n  \"fastembed_sparse\",\n  \"huggingface_sparse\",\n]);\n\n/**\n * Union type covering both dense and sparse embedding functions.\n */\nexport type AnyEmbeddingFunction = EmbeddingFunction | SparseEmbeddingFunction;\n\n/**\n * Registers an embedding function in the global registry.\n * @param name - Unique name for the embedding function\n * @param fn - Embedding function class to register\n * @throws ChromaValueError if name is already registered\n */\nexport const registerEmbeddingFunction = (\n  name: string,\n  fn: EmbeddingFunctionClass,\n) => {\n  if (knownEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Embedding function with name ${name} is already registered.`,\n    );\n  }\n  knownEmbeddingFunctions.set(name, fn);\n};\n\n/**\n * Registers a sparse embedding function in the global registry.\n * @param name - Unique name for the sparse embedding function\n * @param fn - Sparse embedding function class to register\n * @throws ChromaValueError if name is already registered\n */\nexport const registerSparseEmbeddingFunction = (\n  name: string,\n  fn: SparseEmbeddingFunctionClass,\n) => {\n  if (knownSparseEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Sparse embedding function with name ${name} is already registered.`,\n    );\n  }\n  knownSparseEmbeddingFunctions.set(name, fn);\n};\n\n/**\n * Retrieves and instantiates an embedding function from configuration.\n * @returns EmbeddingFunction instance or undefined if it cannot be constructed\n */\nexport const getEmbeddingFunction = async (args: {\n  collectionName: string;\n  client: ChromaClient;\n  efConfig?: EmbeddingFunctionConfiguration;\n}) => {\n  const { collectionName, client, efConfig } = args;\n\n  if (!efConfig) {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type === \"legacy\") {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type === \"unknown\") {\n    console.warn(\n      `Unknown embedding function configuration for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type !== \"known\") {\n    return undefined;\n  }\n\n  if (unsupportedEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      `Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  const packageName = pythonEmbeddingFunctions[efConfig.name] || efConfig.name;\n\n  if (packageName === \"default-embed\") {\n    await getDefaultEFConfig();\n  }\n\n  let embeddingFunction = knownEmbeddingFunctions.get(packageName);\n  if (!embeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await import(fullPackageName);\n      embeddingFunction = knownEmbeddingFunctions.get(packageName);\n    } catch (error) {\n      // Dynamic loading failed, proceed with warning\n    }\n\n    if (!embeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} embedding function. However, the @chroma-core/${packageName} package is not installed. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${packageName} package.`,\n      );\n      return undefined;\n    }\n  }\n\n  let constructorConfig: Record<string, any> =\n    efConfig.type === \"known\" ? (efConfig.config as Record<string, any>) : {};\n\n  try {\n    if (embeddingFunction.buildFromConfig) {\n      return embeddingFunction.buildFromConfig(constructorConfig, client);\n    }\n\n    console.warn(\n      `Embedding function ${packageName} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  } catch (e) {\n    console.warn(\n      `Embedding function ${packageName} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`,\n    );\n    return undefined;\n  }\n};\n\n/**\n * Retrieves and instantiates a sparse embedding function from configuration.\n * @returns SparseEmbeddingFunction instance or undefined if it cannot be constructed\n */\nexport const getSparseEmbeddingFunction = async (\n  collectionName: string,\n  client: ChromaClient,\n  efConfig?: EmbeddingFunctionConfiguration,\n) => {\n  if (!efConfig) {\n    return undefined;\n  }\n\n  if (efConfig.type === \"legacy\") {\n    return undefined;\n  }\n\n  if (efConfig.type !== \"known\") {\n    return undefined;\n  }\n\n  if (unsupportedSparseEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      \"Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.\",\n    );\n    return undefined;\n  }\n\n  const packageName =\n    pythonSparseEmbeddingFunctions[efConfig.name] || efConfig.name;\n\n  let sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n  if (!sparseEmbeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await import(fullPackageName);\n      sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n    } catch (error) {\n      // Dynamic loading failed, proceed with warning\n    }\n\n    if (!sparseEmbeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} sparse embedding function. However, the @chroma-core/${packageName} package is not installed.`,\n      );\n      return undefined;\n    }\n  }\n\n  let constructorConfig: Record<string, any> =\n    efConfig.type === \"known\" ? (efConfig.config as Record<string, any>) : {};\n\n  try {\n    if (sparseEmbeddingFunction.buildFromConfig) {\n      return sparseEmbeddingFunction.buildFromConfig(constructorConfig, client);\n    }\n\n    console.warn(\n      `Sparse embedding function ${packageName} does not define a 'buildFromConfig' function.`,\n    );\n    return undefined;\n  } catch (e) {\n    console.warn(\n      `Sparse embedding function ${packageName} failed to build with config: ${constructorConfig}. Error: ${e}`,\n    );\n    return undefined;\n  }\n};\n\n/**\n * Serializes an embedding function to configuration format.\n * @param embeddingFunction - User provided embedding function\n * @param configEmbeddingFunction - Collection config embedding function\n * @returns Configuration object that can recreate the function\n */\nexport const serializeEmbeddingFunction = ({\n  embeddingFunction,\n  configEmbeddingFunction,\n}: {\n  embeddingFunction?: EmbeddingFunction;\n  configEmbeddingFunction?: EmbeddingFunction;\n}): EmbeddingFunctionConfiguration | undefined => {\n  if (embeddingFunction && configEmbeddingFunction) {\n    throw new ChromaValueError(\n      \"Embedding function provided when already defined in the collection configuration\",\n    );\n  }\n\n  if (!embeddingFunction && !configEmbeddingFunction) {\n    return undefined;\n  }\n\n  const ef = embeddingFunction || configEmbeddingFunction!;\n  if (\n    !ef.getConfig ||\n    !ef.name ||\n    !(ef.constructor as EmbeddingFunctionClass).buildFromConfig\n  ) {\n    return { type: \"legacy\" };\n  }\n\n  if (ef.validateConfig) ef.validateConfig(ef.getConfig());\n  return {\n    name: ef.name,\n    type: \"known\",\n    config: ef.getConfig(),\n  };\n};\n\n/**\n * Gets the configuration for the default embedding function.\n * Dynamically imports and registers the default embedding function if needed.\n * @returns Promise resolving to default embedding function configuration\n * @throws Error if default embedding function cannot be loaded\n */\nexport const getDefaultEFConfig =\n  async (): Promise<EmbeddingFunctionConfiguration> => {\n    try {\n      const { DefaultEmbeddingFunction } = await import(\n        \"@chroma-core/default-embed\"\n      );\n      if (!knownEmbeddingFunctions.has(\"default-embed\")) {\n        registerEmbeddingFunction(\"default-embed\", DefaultEmbeddingFunction);\n      }\n    } catch (e) {\n      console.warn(\n        \"Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function\",\n      );\n    }\n    return {\n      name: \"default\",\n      type: \"known\",\n      config: {},\n    };\n  };\n","import { ChromaValueError } from \"./errors\";\nimport {\n  EmbeddingFunctionConfiguration,\n  HnswConfiguration as ApiHnswConfiguration,\n  SpannConfiguration,\n  UpdateCollectionConfiguration as ApiUpdateCollectionConfiguration,\n} from \"./api\";\nimport {\n  EmbeddingFunction,\n  EmbeddingFunctionSpace,\n  getDefaultEFConfig,\n  getEmbeddingFunction,\n  serializeEmbeddingFunction,\n} from \"./embedding-function\";\nimport { CollectionMetadata } from \"./types\";\nimport { Schema } from \"./schema\";\nimport { ChromaClient } from \"./chroma-client\";\n\nexport interface CollectionConfiguration {\n  embeddingFunction?: EmbeddingFunctionConfiguration | null;\n  hnsw?: HNSWConfiguration | null;\n  spann?: SpannConfiguration | null;\n}\n\nexport type HNSWConfiguration = ApiHnswConfiguration & {\n  batch_size?: number | null;\n  num_threads?: number | null;\n};\n\nexport type CreateCollectionConfiguration = Omit<\n  CollectionConfiguration,\n  \"embeddingFunction\"\n> & { embeddingFunction?: EmbeddingFunction };\n\nexport interface UpdateCollectionConfiguration {\n  embeddingFunction?: EmbeddingFunction;\n  hnsw?: UpdateHNSWConfiguration;\n  spann?: UpdateSPANNConfiguration;\n}\n\nexport interface UpdateHNSWConfiguration {\n  batch_size?: number;\n  ef_search?: number;\n  num_threads?: number;\n  resize_factor?: number;\n  sync_threshold?: number;\n}\n\nexport interface UpdateSPANNConfiguration {\n  search_nprobe?: number;\n  ef_search?: number;\n}\n\n/**\n * Validate user provided collection configuration and embedding function. Returns a\n * CollectionConfiguration to be used in collection creation.\n */\nexport const processCreateCollectionConfig = async ({\n  configuration,\n  embeddingFunction,\n  metadata,\n  schema,\n}: {\n  configuration?: CreateCollectionConfiguration;\n  embeddingFunction?: EmbeddingFunction | null;\n  metadata?: CollectionMetadata;\n  schema?: Schema;\n}) => {\n  let schemaEmbeddingFunction: EmbeddingFunction | null | undefined = undefined;\n  if (schema) {\n    schemaEmbeddingFunction = schema.resolveEmbeddingFunction();\n  }\n  if (configuration?.hnsw && configuration?.spann) {\n    throw new ChromaValueError(\n      \"Cannot specify both HNSW and SPANN configurations\",\n    );\n  }\n\n  let embeddingFunctionConfiguration = serializeEmbeddingFunction({\n    embeddingFunction: embeddingFunction ?? undefined,\n    configEmbeddingFunction: configuration?.embeddingFunction,\n  });\n\n  if (\n    !embeddingFunctionConfiguration &&\n    embeddingFunction !== null &&\n    schemaEmbeddingFunction === undefined\n  ) {\n    embeddingFunctionConfiguration = await getDefaultEFConfig();\n  }\n\n  const overallEf = embeddingFunction || configuration?.embeddingFunction;\n\n  if (overallEf && overallEf.defaultSpace && overallEf.supportedSpaces) {\n    if (\n      configuration?.hnsw === undefined &&\n      configuration?.spann === undefined\n    ) {\n      if (metadata === undefined || metadata?.[\"hnsw:space\"] === undefined) {\n        if (!configuration) configuration = {};\n        configuration.hnsw = { space: overallEf.defaultSpace() };\n      }\n    }\n\n    if (\n      configuration?.hnsw &&\n      !configuration.hnsw.space &&\n      overallEf.defaultSpace\n    ) {\n      configuration.hnsw.space = overallEf.defaultSpace();\n    }\n\n    if (\n      configuration?.spann &&\n      !configuration.spann.space &&\n      overallEf.defaultSpace\n    ) {\n      configuration.spann.space = overallEf.defaultSpace();\n    }\n\n    if (overallEf.supportedSpaces) {\n      const supportedSpaces = overallEf.supportedSpaces();\n\n      if (\n        configuration?.hnsw?.space &&\n        !supportedSpaces.includes(configuration.hnsw.space)\n      ) {\n        console.warn(\n          `Space '${\n            configuration.hnsw.space\n          }' is not supported by embedding function '${\n            overallEf.name || \"unknown\"\n          }'. ` + `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n\n      if (\n        configuration?.spann?.space &&\n        !supportedSpaces.includes(configuration.spann.space)\n      ) {\n        console.warn(\n          `Space '${\n            configuration.spann.space\n          }' is not supported by embedding function '${\n            overallEf.name || \"unknown\"\n          }'. ` + `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n\n      if (\n        !configuration?.hnsw &&\n        !configuration?.spann &&\n        metadata &&\n        typeof metadata[\"hnsw:space\"] === \"string\" &&\n        !supportedSpaces.includes(\n          metadata[\"hnsw:space\"] as EmbeddingFunctionSpace,\n        )\n      ) {\n        console.warn(\n          `Space '${\n            metadata[\"hnsw:space\"]\n          }' from metadata is not supported by embedding function '${\n            overallEf.name || \"unknown\"\n          }'. ` + `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n    }\n  }\n\n  return {\n    ...(configuration || {}),\n    embedding_function: embeddingFunctionConfiguration,\n  } as CollectionConfiguration;\n};\n\n/**\n *\n */\nexport const processUpdateCollectionConfig = async ({\n  collectionName,\n  currentConfiguration,\n  currentEmbeddingFunction,\n  newConfiguration,\n  client,\n}: {\n  collectionName: string;\n  currentConfiguration: CollectionConfiguration;\n  currentEmbeddingFunction?: EmbeddingFunction;\n  newConfiguration: UpdateCollectionConfiguration;\n  client: ChromaClient;\n}): Promise<{\n  updateConfiguration?: ApiUpdateCollectionConfiguration;\n  updateEmbeddingFunction?: EmbeddingFunction;\n}> => {\n  if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid HNSW config provided in UpdateCollectionConfiguration\",\n    );\n  }\n\n  if (newConfiguration.spann && typeof newConfiguration.spann !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid SPANN config provided in UpdateCollectionConfiguration\",\n    );\n  }\n\n  const embeddingFunction =\n    currentEmbeddingFunction ||\n    (await getEmbeddingFunction({\n      collectionName: collectionName,\n      client,\n      efConfig: currentConfiguration.embeddingFunction ?? undefined,\n    }));\n\n  const newEmbeddingFunction = newConfiguration.embeddingFunction;\n\n  if (\n    embeddingFunction &&\n    embeddingFunction.validateConfigUpdate &&\n    newEmbeddingFunction &&\n    newEmbeddingFunction.getConfig\n  ) {\n    embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());\n  }\n\n  return {\n    updateConfiguration: {\n      hnsw: newConfiguration.hnsw,\n      spann: newConfiguration.spann,\n      embedding_function:\n        newEmbeddingFunction &&\n        serializeEmbeddingFunction({ embeddingFunction: newEmbeddingFunction }),\n    },\n    updateEmbeddingFunction: newEmbeddingFunction,\n  };\n};\n","export type IterableInput<T> = Iterable<T> | ArrayLike<T>;\n\nexport const isPlainObject = (\n  value: unknown,\n): value is Record<string, unknown> => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === Object.prototype || prototype === null;\n};\n\nexport const deepClone = <T>(value: T): T =>\n  JSON.parse(JSON.stringify(value)) as T;\n\nexport const iterableToArray = <T>(values: IterableInput<T>): T[] => {\n  if (Array.isArray(values)) {\n    return values.slice();\n  }\n  return Array.from(values as Iterable<T>);\n};\n\nexport const assertNonEmptyArray = (values: unknown[], message: string) => {\n  if (values.length === 0) {\n    throw new Error(message);\n  }\n};\n","import { isPlainObject } from \"./common\";\n\nexport type WhereJSON = Record<string, unknown>;\nexport type WhereInput = WhereExpression | WhereJSON | null | undefined;\n\nabstract class WhereExpressionBase {\n  public abstract toJSON(): WhereJSON;\n\n  public and(other: WhereInput): WhereExpression {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this as unknown as WhereExpression;\n    }\n    return AndWhere.combine(this as unknown as WhereExpression, target);\n  }\n\n  public or(other: WhereInput): WhereExpression {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this as unknown as WhereExpression;\n    }\n    return OrWhere.combine(this as unknown as WhereExpression, target);\n  }\n}\n\nexport abstract class WhereExpression extends WhereExpressionBase {\n  public static from(input: WhereInput): WhereExpression | undefined {\n    if (input instanceof WhereExpression) {\n      return input;\n    }\n    if (input === null || input === undefined) {\n      return undefined;\n    }\n    if (!isPlainObject(input)) {\n      throw new TypeError(\n        \"Where input must be a WhereExpression or plain object\",\n      );\n    }\n    return parseWhereDict(input);\n  }\n}\n\nclass AndWhere extends WhereExpression {\n  constructor(private readonly conditions: WhereExpression[]) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return { $and: this.conditions.map((condition) => condition.toJSON()) };\n  }\n\n  public get operands(): WhereExpression[] {\n    return this.conditions.slice();\n  }\n\n  public static combine(\n    left: WhereExpression,\n    right: WhereExpression,\n  ): WhereExpression {\n    const flattened: WhereExpression[] = [];\n\n    const add = (expr: WhereExpression) => {\n      if (expr instanceof AndWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n\n    add(left);\n    add(right);\n\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n\n    return new AndWhere(flattened);\n  }\n}\n\nclass OrWhere extends WhereExpression {\n  constructor(private readonly conditions: WhereExpression[]) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return { $or: this.conditions.map((condition) => condition.toJSON()) };\n  }\n\n  public get operands(): WhereExpression[] {\n    return this.conditions.slice();\n  }\n\n  public static combine(\n    left: WhereExpression,\n    right: WhereExpression,\n  ): WhereExpression {\n    const flattened: WhereExpression[] = [];\n\n    const add = (expr: WhereExpression) => {\n      if (expr instanceof OrWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n\n    add(left);\n    add(right);\n\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n\n    return new OrWhere(flattened);\n  }\n}\n\nclass ComparisonWhere extends WhereExpression {\n  constructor(\n    private readonly key: string,\n    private readonly operator: string,\n    private readonly value: unknown,\n  ) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return {\n      [this.key]: {\n        [this.operator]: this.value,\n      },\n    };\n  }\n}\n\nconst comparisonOperatorMap = new Map<\n  string,\n  (key: string, value: unknown) => WhereExpression\n>([\n  [\"$eq\", (key, value) => new ComparisonWhere(key, \"$eq\", value)],\n  [\"$ne\", (key, value) => new ComparisonWhere(key, \"$ne\", value)],\n  [\"$gt\", (key, value) => new ComparisonWhere(key, \"$gt\", value)],\n  [\"$gte\", (key, value) => new ComparisonWhere(key, \"$gte\", value)],\n  [\"$lt\", (key, value) => new ComparisonWhere(key, \"$lt\", value)],\n  [\"$lte\", (key, value) => new ComparisonWhere(key, \"$lte\", value)],\n  [\"$in\", (key, value) => new ComparisonWhere(key, \"$in\", value)],\n  [\"$nin\", (key, value) => new ComparisonWhere(key, \"$nin\", value)],\n  [\"$contains\", (key, value) => new ComparisonWhere(key, \"$contains\", value)],\n  [\n    \"$not_contains\",\n    (key, value) => new ComparisonWhere(key, \"$not_contains\", value),\n  ],\n  [\"$regex\", (key, value) => new ComparisonWhere(key, \"$regex\", value)],\n  [\"$not_regex\", (key, value) => new ComparisonWhere(key, \"$not_regex\", value)],\n]);\n\nconst parseWhereDict = (data: Record<string, unknown>): WhereExpression => {\n  if (\"$and\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$and cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$and\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$and must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item as WhereInput);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions\n      .slice(1)\n      .reduce(\n        (acc, condition) => AndWhere.combine(acc, condition),\n        conditions[0],\n      );\n  }\n\n  if (\"$or\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$or cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$or\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$or must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item as WhereInput);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions\n      .slice(1)\n      .reduce(\n        (acc, condition) => OrWhere.combine(acc, condition),\n        conditions[0],\n      );\n  }\n\n  const entries = Object.entries(data);\n  if (entries.length !== 1) {\n    throw new Error(\"Where dictionary must contain exactly one field\");\n  }\n\n  const [field, value] = entries[0];\n  if (!isPlainObject(value)) {\n    return new ComparisonWhere(field, \"$eq\", value);\n  }\n\n  const operatorEntries = Object.entries(value);\n  if (operatorEntries.length !== 1) {\n    throw new Error(\n      `Operator dictionary for field \"${field}\" must contain exactly one operator`,\n    );\n  }\n\n  const [operator, operand] = operatorEntries[0];\n  const factory = comparisonOperatorMap.get(operator);\n  if (!factory) {\n    throw new Error(`Unsupported where operator: ${operator}`);\n  }\n\n  return factory(field, operand);\n};\n\nexport const createComparisonWhere = (\n  key: string,\n  operator: string,\n  value: unknown,\n): WhereExpression => new ComparisonWhere(key, operator, value);\n","import { assertNonEmptyArray, iterableToArray, IterableInput } from \"./common\";\nimport { createComparisonWhere, WhereExpression } from \"./where\";\n\nexport class Key {\n  public static readonly ID = new Key(\"#id\");\n  public static readonly DOCUMENT = new Key(\"#document\");\n  public static readonly EMBEDDING = new Key(\"#embedding\");\n  public static readonly METADATA = new Key(\"#metadata\");\n  public static readonly SCORE = new Key(\"#score\");\n\n  constructor(public readonly name: string) {}\n\n  public eq(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$eq\", value);\n  }\n\n  public ne(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$ne\", value);\n  }\n\n  public gt(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$gt\", value);\n  }\n\n  public gte(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$gte\", value);\n  }\n\n  public lt(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$lt\", value);\n  }\n\n  public lte(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$lte\", value);\n  }\n\n  public isIn(values: IterableInput<unknown>): WhereExpression {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$in requires at least one value\");\n    return createComparisonWhere(this.name, \"$in\", array);\n  }\n\n  public notIn(values: IterableInput<unknown>): WhereExpression {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$nin requires at least one value\");\n    return createComparisonWhere(this.name, \"$nin\", array);\n  }\n\n  public contains(value: string): WhereExpression {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$contains\", value);\n  }\n\n  public notContains(value: string): WhereExpression {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$not_contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$not_contains\", value);\n  }\n\n  public regex(pattern: string): WhereExpression {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$regex\", pattern);\n  }\n\n  public notRegex(pattern: string): WhereExpression {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$not_regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$not_regex\", pattern);\n  }\n}\n\nexport interface KeyFactory {\n  (name: string): Key;\n  ID: Key;\n  DOCUMENT: Key;\n  EMBEDDING: Key;\n  METADATA: Key;\n  SCORE: Key;\n}\n\nconst createKeyFactory = (): KeyFactory => {\n  const factory = ((name: string) => new Key(name)) as KeyFactory;\n  factory.ID = Key.ID;\n  factory.DOCUMENT = Key.DOCUMENT;\n  factory.EMBEDDING = Key.EMBEDDING;\n  factory.METADATA = Key.METADATA;\n  factory.SCORE = Key.SCORE;\n  return factory;\n};\n\nexport const K: KeyFactory = createKeyFactory();\n","export interface LimitOptions {\n  offset?: number;\n  limit?: number | null | undefined;\n}\n\nexport type LimitInput = Limit | number | LimitOptions | null | undefined;\n\nexport class Limit {\n  public readonly offset: number;\n  public readonly limit?: number;\n\n  constructor(options: LimitOptions = {}) {\n    const { offset = 0, limit } = options;\n\n    if (!Number.isInteger(offset) || offset < 0) {\n      throw new TypeError(\"Limit offset must be a non-negative integer\");\n    }\n\n    if (limit !== null && limit !== undefined) {\n      if (!Number.isInteger(limit) || limit <= 0) {\n        throw new TypeError(\"Limit must be a positive integer when provided\");\n      }\n      this.limit = limit;\n    }\n\n    this.offset = offset;\n  }\n\n  public static from(input: LimitInput, offsetOverride?: number): Limit {\n    if (input instanceof Limit) {\n      return new Limit({ offset: input.offset, limit: input.limit });\n    }\n\n    if (typeof input === \"number\") {\n      return new Limit({ limit: input, offset: offsetOverride ?? 0 });\n    }\n\n    if (input === null || input === undefined) {\n      return new Limit();\n    }\n\n    if (typeof input === \"object\") {\n      return new Limit(input as LimitOptions);\n    }\n\n    throw new TypeError(\"Invalid limit input\");\n  }\n\n  public toJSON(): { offset: number; limit?: number } {\n    const result: { offset: number; limit?: number } = { offset: this.offset };\n    if (this.limit !== undefined) {\n      result.limit = this.limit;\n    }\n    return result;\n  }\n}\n","import { Key } from \"./key\";\n\nexport type SelectKeyInput = string | Key;\n\nexport type SelectInput =\n  | Select\n  | Iterable<SelectKeyInput>\n  | { keys?: Iterable<SelectKeyInput> }\n  | null\n  | undefined;\n\nexport class Select {\n  private readonly keys: string[];\n\n  constructor(keys: Iterable<SelectKeyInput> = []) {\n    const unique = new Set<string>();\n    for (const key of keys) {\n      const normalized = key instanceof Key ? key.name : key;\n      if (typeof normalized !== \"string\") {\n        throw new TypeError(\"Select keys must be strings or Key instances\");\n      }\n      unique.add(normalized);\n    }\n    this.keys = Array.from(unique);\n  }\n\n  public static from(input: SelectInput): Select {\n    if (input instanceof Select) {\n      return new Select(input.keys);\n    }\n\n    if (input === null || input === undefined) {\n      return new Select();\n    }\n\n    if (Symbol.iterator in Object(input)) {\n      return new Select(input as Iterable<SelectKeyInput>);\n    }\n\n    if (\n      typeof input === \"object\" &&\n      \"keys\" in (input as Record<string, unknown>)\n    ) {\n      const { keys } = input as { keys?: Iterable<SelectKeyInput> };\n      return new Select(keys ?? []);\n    }\n\n    throw new TypeError(\"Unsupported select input\");\n  }\n\n  public static all(): Select {\n    return new Select([Key.DOCUMENT, Key.EMBEDDING, Key.METADATA, Key.SCORE]);\n  }\n\n  public get values(): string[] {\n    return this.keys.slice();\n  }\n\n  public toJSON(): { keys: string[] } {\n    return { keys: this.values };\n  }\n}\n","import type { SparseVector } from \"../../api\";\nimport { deepClone, isPlainObject, IterableInput } from \"./common\";\nimport { Key } from \"./key\";\n\nexport type RankLiteral = Record<string, unknown>;\nexport type RankInput =\n  | RankExpression\n  | RankLiteral\n  | number\n  | null\n  | undefined;\n\nconst requireNumber = (value: unknown, message: string): number => {\n  if (\n    typeof value !== \"number\" ||\n    Number.isNaN(value) ||\n    !Number.isFinite(value)\n  ) {\n    throw new TypeError(message);\n  }\n  return value;\n};\n\nabstract class RankExpressionBase {\n  public abstract toJSON(): Record<string, unknown>;\n\n  public add(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `add operand ${index}`)),\n    ];\n    return SumRankExpression.create(expressions);\n  }\n\n  public subtract(other: RankInput): RankExpression {\n    return new SubRankExpression(\n      this as unknown as RankExpression,\n      requireRank(other, \"subtract operand\"),\n    );\n  }\n\n  public multiply(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) =>\n        requireRank(item, `multiply operand ${index}`),\n      ),\n    ];\n    return MulRankExpression.create(expressions);\n  }\n\n  public divide(other: RankInput): RankExpression {\n    return new DivRankExpression(\n      this as unknown as RankExpression,\n      requireRank(other, \"divide operand\"),\n    );\n  }\n\n  public negate(): RankExpression {\n    return this.multiply(-1);\n  }\n\n  public abs(): RankExpression {\n    return new AbsRankExpression(this as unknown as RankExpression);\n  }\n\n  public exp(): RankExpression {\n    return new ExpRankExpression(this as unknown as RankExpression);\n  }\n\n  public log(): RankExpression {\n    return new LogRankExpression(this as unknown as RankExpression);\n  }\n\n  public max(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `max operand ${index}`)),\n    ];\n    return MaxRankExpression.create(expressions);\n  }\n\n  public min(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `min operand ${index}`)),\n    ];\n    return MinRankExpression.create(expressions);\n  }\n}\n\nexport abstract class RankExpression extends RankExpressionBase {\n  public static from(input: RankInput): RankExpression | undefined {\n    if (input instanceof RankExpression) {\n      return input;\n    }\n    if (input === null || input === undefined) {\n      return undefined;\n    }\n    if (typeof input === \"number\") {\n      return new ValueRankExpression(input);\n    }\n    if (isPlainObject(input)) {\n      return new RawRankExpression(input);\n    }\n    throw new TypeError(\n      \"Rank input must be a RankExpression, number, or plain object\",\n    );\n  }\n}\n\nclass RawRankExpression extends RankExpression {\n  constructor(private readonly raw: RankLiteral) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return deepClone(this.raw);\n  }\n}\n\nclass ValueRankExpression extends RankExpression {\n  constructor(private readonly value: number) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $val: this.value };\n  }\n}\n\nclass SumRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof SumRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new SumRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $sum: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass SubRankExpression extends RankExpression {\n  constructor(\n    private readonly left: RankExpression,\n    private readonly right: RankExpression,\n  ) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return {\n      $sub: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON(),\n      },\n    };\n  }\n}\n\nclass MulRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MulRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MulRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $mul: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass DivRankExpression extends RankExpression {\n  constructor(\n    private readonly left: RankExpression,\n    private readonly right: RankExpression,\n  ) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return {\n      $div: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON(),\n      },\n    };\n  }\n}\n\nclass AbsRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $abs: this.operand.toJSON() };\n  }\n}\n\nclass ExpRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $exp: this.operand.toJSON() };\n  }\n}\n\nclass LogRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $log: this.operand.toJSON() };\n  }\n}\n\nclass MaxRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MaxRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MaxRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $max: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass MinRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MinRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MinRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $min: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass KnnRankExpression extends RankExpression {\n  constructor(private readonly config: KnnOptionsNormalized) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    const base: Record<string, unknown> = {\n      query: this.config.query,\n      key: this.config.key,\n      limit: this.config.limit,\n    };\n\n    if (this.config.defaultValue !== undefined) {\n      base.default = this.config.defaultValue;\n    }\n\n    if (this.config.returnRank) {\n      base.return_rank = true;\n    }\n\n    return { $knn: base };\n  }\n}\n\ninterface KnnOptionsNormalized {\n  query: number[] | SparseVector | string;\n  key: string;\n  limit: number;\n  defaultValue?: number;\n  returnRank: boolean;\n}\n\nexport interface KnnOptions {\n  query: IterableInput<number> | SparseVector | string;\n  key?: string | Key;\n  limit?: number;\n  default?: number | null;\n  returnRank?: boolean;\n}\n\nconst normalizeDenseVector = (vector: IterableInput<number>): number[] => {\n  if (Array.isArray(vector)) {\n    return vector.slice();\n  }\n  return Array.from(vector as Iterable<number>, (value) => {\n    if (\n      typeof value !== \"number\" ||\n      Number.isNaN(value) ||\n      !Number.isFinite(value)\n    ) {\n      throw new TypeError(\"Dense query vector values must be finite numbers\");\n    }\n    return value;\n  });\n};\n\nconst normalizeKnnOptions = (options: KnnOptions): KnnOptionsNormalized => {\n  const limit = options.limit ?? 128;\n  if (!Number.isInteger(limit) || limit <= 0) {\n    throw new TypeError(\"Knn limit must be a positive integer\");\n  }\n\n  const queryInput = options.query;\n\n  let query: number[] | SparseVector | string;\n  if (typeof queryInput === \"string\") {\n    query = queryInput;\n  } else if (\n    isPlainObject(queryInput) &&\n    Array.isArray((queryInput as SparseVector).indices) &&\n    Array.isArray((queryInput as SparseVector).values)\n  ) {\n    const sparse = queryInput as SparseVector;\n    query = {\n      indices: sparse.indices.slice(),\n      values: sparse.values.slice(),\n    };\n  } else {\n    query = normalizeDenseVector(queryInput as IterableInput<number>);\n  }\n\n  const key =\n    options.key instanceof Key ? options.key.name : options.key ?? \"#embedding\";\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"Knn key must be a string or Key instance\");\n  }\n\n  const defaultValue =\n    options.default === null || options.default === undefined\n      ? undefined\n      : requireNumber(options.default, \"Knn default must be a number\");\n\n  if (defaultValue !== undefined && !Number.isFinite(defaultValue)) {\n    throw new TypeError(\"Knn default must be a finite number\");\n  }\n\n  return {\n    query:\n      Array.isArray(query) || typeof query === \"string\"\n        ? query\n        : deepClone(query),\n    key,\n    limit,\n    defaultValue,\n    returnRank: options.returnRank ?? false,\n  };\n};\n\nconst requireRank = (input: RankInput, context: string): RankExpression => {\n  const result = RankExpression.from(input);\n  if (!result) {\n    throw new TypeError(`${context} must be a rank expression`);\n  }\n  return result;\n};\n\nexport const Val = (value: number): RankExpression =>\n  new ValueRankExpression(requireNumber(value, \"Val requires a numeric value\"));\n\nexport const Knn = (options: KnnOptions): RankExpression =>\n  new KnnRankExpression(normalizeKnnOptions(options));\n\nexport interface RrfOptions {\n  ranks: RankInput[];\n  k?: number;\n  weights?: number[];\n  normalize?: boolean;\n}\n\nexport const Rrf = ({\n  ranks,\n  k = 60,\n  weights,\n  normalize = false,\n}: RrfOptions): RankExpression => {\n  if (!Number.isInteger(k) || k <= 0) {\n    throw new TypeError(\"Rrf k must be a positive integer\");\n  }\n  if (!Array.isArray(ranks) || ranks.length === 0) {\n    throw new TypeError(\"Rrf requires at least one rank expression\");\n  }\n\n  const expressions = ranks.map((rank, index) =>\n    requireRank(rank, `ranks[${index}]`),\n  );\n\n  let weightValues = weights\n    ? weights.slice()\n    : new Array(expressions.length).fill(1);\n  if (weightValues.length !== expressions.length) {\n    throw new Error(\"Number of weights must match number of ranks\");\n  }\n  if (weightValues.some((value) => typeof value !== \"number\" || value < 0)) {\n    throw new TypeError(\"Weights must be non-negative numbers\");\n  }\n\n  if (normalize) {\n    const total = weightValues.reduce((sum, value) => sum + value, 0);\n    if (total <= 0) {\n      throw new Error(\n        \"Weights must sum to a positive value when normalize=true\",\n      );\n    }\n    weightValues = weightValues.map((value) => value / total);\n  }\n\n  const terms = expressions.map((rank, index) => {\n    const weight = weightValues[index];\n    const numerator = Val(weight);\n    const denominator = rank.add(k);\n    return numerator.divide(denominator);\n  });\n\n  const fused = terms.reduce((acc, term) => acc.add(term));\n  return fused.negate();\n};\n\nexport const Sum = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Sum requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) =>\n    requireRank(rank, `Sum operand ${index}`),\n  );\n  return SumRankExpression.create(expressions);\n};\n\nexport const Sub = (left: RankInput, right: RankInput): RankExpression =>\n  new SubRankExpression(\n    requireRank(left, \"Sub left\"),\n    requireRank(right, \"Sub right\"),\n  );\n\nexport const Mul = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Mul requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) =>\n    requireRank(rank, `Mul operand ${index}`),\n  );\n  return MulRankExpression.create(expressions);\n};\n\nexport const Div = (left: RankInput, right: RankInput): RankExpression =>\n  new DivRankExpression(\n    requireRank(left, \"Div left\"),\n    requireRank(right, \"Div right\"),\n  );\n\nexport const Abs = (input: RankInput): RankExpression =>\n  requireRank(input, \"Abs\").abs();\n\nexport const Exp = (input: RankInput): RankExpression =>\n  requireRank(input, \"Exp\").exp();\n\nexport const Log = (input: RankInput): RankExpression =>\n  requireRank(input, \"Log\").log();\n\nexport const Max = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Max requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) =>\n    requireRank(rank, `Max operand ${index}`),\n  );\n  return MaxRankExpression.create(expressions);\n};\n\nexport const Min = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Min requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) =>\n    requireRank(rank, `Min operand ${index}`),\n  );\n  return MinRankExpression.create(expressions);\n};\n","import { isPlainObject } from \"./common\";\nimport { Key } from \"./key\";\n\nexport interface MinKJSON {\n  keys: string[];\n  k: number;\n}\n\nexport interface MaxKJSON {\n  keys: string[];\n  k: number;\n}\n\nexport type AggregateJSON = { $min_k: MinKJSON } | { $max_k: MaxKJSON };\n\nexport type AggregateInput = Aggregate | AggregateJSON;\n\nexport abstract class Aggregate {\n  public abstract toJSON(): AggregateJSON;\n\n  public static from(input: AggregateInput): Aggregate {\n    if (input instanceof Aggregate) {\n      return input;\n    }\n    if (isPlainObject(input)) {\n      if (\"$min_k\" in input) {\n        const data = input.$min_k as MinKJSON;\n        return new MinK(\n          data.keys.map((k) => new Key(k)),\n          data.k,\n        );\n      }\n      if (\"$max_k\" in input) {\n        const data = input.$max_k as MaxKJSON;\n        return new MaxK(\n          data.keys.map((k) => new Key(k)),\n          data.k,\n        );\n      }\n    }\n    throw new TypeError(\n      \"Aggregate input must be an Aggregate instance or object with $min_k or $max_k\",\n    );\n  }\n\n  public static minK(keys: (Key | string)[], k: number): MinK {\n    return new MinK(\n      keys.map((key) => (key instanceof Key ? key : new Key(key))),\n      k,\n    );\n  }\n\n  public static maxK(keys: (Key | string)[], k: number): MaxK {\n    return new MaxK(\n      keys.map((key) => (key instanceof Key ? key : new Key(key))),\n      k,\n    );\n  }\n}\n\nexport class MinK extends Aggregate {\n  constructor(public readonly keys: Key[], public readonly k: number) {\n    super();\n    if (keys.length === 0) {\n      throw new Error(\"MinK keys cannot be empty\");\n    }\n    if (k <= 0) {\n      throw new Error(\"MinK k must be positive\");\n    }\n  }\n\n  public toJSON(): AggregateJSON {\n    return {\n      $min_k: {\n        keys: this.keys.map((key) => key.name),\n        k: this.k,\n      },\n    };\n  }\n}\n\nexport class MaxK extends Aggregate {\n  constructor(public readonly keys: Key[], public readonly k: number) {\n    super();\n    if (keys.length === 0) {\n      throw new Error(\"MaxK keys cannot be empty\");\n    }\n    if (k <= 0) {\n      throw new Error(\"MaxK k must be positive\");\n    }\n  }\n\n  public toJSON(): AggregateJSON {\n    return {\n      $max_k: {\n        keys: this.keys.map((key) => key.name),\n        k: this.k,\n      },\n    };\n  }\n}\n\nexport interface GroupByJSON {\n  keys: string[];\n  aggregate: AggregateJSON;\n}\n\nexport type GroupByInput = GroupBy | GroupByJSON;\n\nexport class GroupBy {\n  constructor(\n    public readonly keys: Key[],\n    public readonly aggregate: Aggregate,\n  ) {\n    if (keys.length === 0) {\n      throw new Error(\"GroupBy keys cannot be empty\");\n    }\n  }\n\n  public static from(input: GroupByInput | undefined): GroupBy | undefined {\n    if (input === undefined || input === null) {\n      return undefined;\n    }\n    if (input instanceof GroupBy) {\n      return input;\n    }\n    if (isPlainObject(input)) {\n      const data = input as GroupByJSON;\n      if (!data.keys || !Array.isArray(data.keys)) {\n        throw new TypeError(\"GroupBy requires 'keys' array\");\n      }\n      if (!data.aggregate) {\n        throw new TypeError(\"GroupBy requires 'aggregate'\");\n      }\n      return new GroupBy(\n        data.keys.map((k) => new Key(k)),\n        Aggregate.from(data.aggregate),\n      );\n    }\n    throw new TypeError(\n      \"GroupBy input must be a GroupBy instance or plain object\",\n    );\n  }\n\n  public toJSON(): GroupByJSON {\n    return {\n      keys: this.keys.map((key) => key.name),\n      aggregate: this.aggregate.toJSON(),\n    };\n  }\n}\n","import type { SearchPayload } from \"../../api\";\nimport type { GroupByInput } from \"./groupBy\";\nimport { GroupBy } from \"./groupBy\";\nimport type { LimitInput } from \"./limit\";\nimport { Limit } from \"./limit\";\nimport type { RankInput } from \"./rank\";\nimport { RankExpression } from \"./rank\";\nimport type { SelectInput, SelectKeyInput } from \"./select\";\nimport { Select } from \"./select\";\nimport type { WhereInput } from \"./where\";\nimport { WhereExpression } from \"./where\";\n\ninterface SearchParts {\n  where?: WhereExpression;\n  rank?: RankExpression;\n  groupBy?: GroupBy;\n  limit: Limit;\n  select: Select;\n}\n\nexport interface SearchInit {\n  where?: WhereInput;\n  rank?: RankInput;\n  groupBy?: GroupByInput;\n  limit?: LimitInput;\n  select?: SelectInput;\n}\n\nexport class Search {\n  private _where?: WhereExpression;\n  private _rank?: RankExpression;\n  private _groupBy?: GroupBy;\n  private _limit: Limit;\n  private _select: Select;\n\n  constructor(init: SearchInit = {}) {\n    this._where = init.where ? WhereExpression.from(init.where) : undefined;\n    this._rank = init.rank ? RankExpression.from(init.rank) : undefined;\n    this._groupBy = init.groupBy ? GroupBy.from(init.groupBy) : undefined;\n    this._limit = Limit.from(init.limit ?? undefined);\n    this._select = Select.from(init.select ?? undefined);\n  }\n\n  private clone(overrides: Partial<SearchParts>): Search {\n    const next = Object.create(Search.prototype) as Search;\n    next._where = overrides.where ?? this._where;\n    next._rank = overrides.rank ?? this._rank;\n    next._groupBy = overrides.groupBy ?? this._groupBy;\n    next._limit = overrides.limit ?? this._limit;\n    next._select = overrides.select ?? this._select;\n    return next;\n  }\n\n  public where(where?: WhereInput): Search {\n    return this.clone({ where: WhereExpression.from(where) });\n  }\n\n  public rank(rank?: RankInput): Search {\n    return this.clone({ rank: RankExpression.from(rank ?? undefined) });\n  }\n\n  public groupBy(groupBy?: GroupByInput): Search {\n    return this.clone({ groupBy: GroupBy.from(groupBy) });\n  }\n\n  public limit(limit?: LimitInput, offset?: number): Search {\n    if (typeof limit === \"number\") {\n      return this.clone({ limit: Limit.from(limit, offset) });\n    }\n    return this.clone({ limit: Limit.from(limit ?? undefined) });\n  }\n\n  public select(keys?: SelectInput): Search;\n  public select(...keys: SelectKeyInput[]): Search;\n  public select(\n    first?: SelectInput | SelectKeyInput,\n    ...rest: SelectKeyInput[]\n  ): Search {\n    if (Array.isArray(first) || first instanceof Set) {\n      return this.clone({\n        select: Select.from(first as Iterable<SelectKeyInput>),\n      });\n    }\n\n    if (first instanceof Select) {\n      return this.clone({ select: Select.from(first) });\n    }\n\n    if (typeof first === \"object\" && first !== null && \"keys\" in first) {\n      return this.clone({ select: Select.from(first as SelectInput) });\n    }\n\n    const allKeys: SelectKeyInput[] = [];\n    if (first !== undefined) {\n      allKeys.push(first as SelectKeyInput);\n    }\n    if (rest.length) {\n      allKeys.push(...rest);\n    }\n\n    return this.clone({ select: Select.from(allKeys) });\n  }\n\n  public selectAll(): Search {\n    return this.clone({ select: Select.all() });\n  }\n\n  public get whereClause(): WhereExpression | undefined {\n    return this._where;\n  }\n\n  public get rankExpression(): RankExpression | undefined {\n    return this._rank;\n  }\n\n  public get groupByConfig(): GroupBy | undefined {\n    return this._groupBy;\n  }\n\n  public get limitConfig(): Limit {\n    return this._limit;\n  }\n\n  public get selectConfig(): Select {\n    return this._select;\n  }\n\n  public toPayload(): SearchPayload {\n    const payload: SearchPayload = {\n      limit: this._limit.toJSON(),\n      select: this._select.toJSON(),\n    };\n\n    if (this._where) {\n      // toJSON returns the plain where-clause structure the service expects (no wrapper).\n      // The generated SearchPayload type still says filter must look like { where_clause: â€¦ }.\n      payload.filter =\n        this._where.toJSON() as unknown as SearchPayload[\"filter\"];\n    }\n\n    if (this._rank) {\n      payload.rank = this._rank.toJSON();\n    }\n\n    if (this._groupBy) {\n      payload.group_by = this._groupBy.toJSON();\n    }\n\n    return payload;\n  }\n}\n\nexport type SearchLike = Search | SearchInit;\n\nexport const toSearch = (input: SearchLike): Search =>\n  input instanceof Search ? input : new Search(input);\n","import type { SearchResponse } from \"../../api\";\nimport type { Metadata } from \"../../types\";\nimport { deserializeMetadatas } from \"../../utils\";\n\nexport interface SearchResultRow {\n  id: string;\n  document?: string | null;\n  embedding?: number[] | null;\n  metadata?: Metadata | null;\n  score?: number | null;\n}\n\nconst normalizePayloadArray = <T>(\n  payload: Array<T[] | null> | null | undefined,\n  count: number,\n): Array<T[] | null> => {\n  if (!payload) {\n    return Array(count).fill(null);\n  }\n  if (payload.length === count) {\n    return payload.map((item) => (item ? item.slice() : null));\n  }\n  const result: Array<T[] | null> = payload.map((item) =>\n    item ? item.slice() : null,\n  );\n  while (result.length < count) {\n    result.push(null);\n  }\n  return result;\n};\n\nexport class SearchResult {\n  public readonly ids: string[][];\n  public readonly documents: Array<Array<string | null> | null>;\n  public readonly embeddings: Array<Array<Array<number> | null> | null>;\n  public readonly metadatas: Array<Array<Metadata | null> | null>;\n  public readonly scores: Array<Array<number | null> | null>;\n  public readonly select: SearchResponse[\"select\"];\n\n  constructor(response: SearchResponse) {\n    this.ids = response.ids;\n    const payloadCount = this.ids.length;\n    this.documents = normalizePayloadArray(response.documents, payloadCount);\n    this.embeddings = normalizePayloadArray(response.embeddings, payloadCount);\n    const rawMetadatas = normalizePayloadArray(\n      response.metadatas,\n      payloadCount,\n    );\n    this.metadatas = rawMetadatas.map((payload) => {\n      if (!payload) {\n        return null;\n      }\n      return deserializeMetadatas(payload) ?? [];\n    });\n    this.scores = normalizePayloadArray(response.scores, payloadCount);\n    this.select = response.select ?? [];\n  }\n\n  public rows(): SearchResultRow[][] {\n    const results: SearchResultRow[][] = [];\n\n    for (\n      let payloadIndex = 0;\n      payloadIndex < this.ids.length;\n      payloadIndex += 1\n    ) {\n      const ids = this.ids[payloadIndex];\n      const docPayload = this.documents[payloadIndex] ?? [];\n      const embedPayload = this.embeddings[payloadIndex] ?? [];\n      const metaPayload = this.metadatas[payloadIndex] ?? [];\n      const scorePayload = this.scores[payloadIndex] ?? [];\n\n      const rows: SearchResultRow[] = ids.map((id, rowIndex) => {\n        const row: SearchResultRow = { id };\n\n        const document = docPayload[rowIndex];\n        if (document !== undefined && document !== null) {\n          row.document = document;\n        }\n\n        const embedding = embedPayload[rowIndex];\n        if (embedding !== undefined && embedding !== null) {\n          row.embedding = embedding;\n        }\n\n        const metadata = metaPayload[rowIndex];\n        if (metadata !== undefined && metadata !== null) {\n          row.metadata = metadata;\n        }\n\n        const score = scorePayload[rowIndex];\n        if (score !== undefined && score !== null) {\n          row.score = score;\n        }\n\n        return row;\n      });\n\n      results.push(rows);\n    }\n\n    return results;\n  }\n}\n","import type {\n  EmbeddingFunctionConfiguration,\n  HnswIndexConfig as ApiHnswIndexConfig,\n  Schema as InternalSchema,\n  Space,\n  SpannIndexConfig as ApiSpannIndexConfig,\n  ValueTypes as ApiValueTypes,\n} from \"./api\";\nimport {\n  AnyEmbeddingFunction,\n  EmbeddingFunction,\n  getEmbeddingFunction,\n  getSparseEmbeddingFunction,\n  SparseEmbeddingFunction,\n} from \"./embedding-function\";\nimport { Key } from \"./execution\";\nimport { ChromaClient } from \"./chroma-client\";\n\nexport const DOCUMENT_KEY = \"#document\";\nexport const EMBEDDING_KEY = \"#embedding\";\n\n// ============================================================================\n// CMEK (Customer-Managed Encryption Key) Support\n// ============================================================================\n\n/**\n * Supported cloud providers for customer-managed encryption keys.\n * Currently only Google Cloud Platform (GCP) is supported.\n */\nexport enum CmekProvider {\n  GCP = \"gcp\",\n}\n\n/**\n * Customer-managed encryption key (CMEK) for collection data encryption.\n *\n * CMEK allows you to use your own encryption keys managed by cloud providers'\n * key management services (KMS) instead of default provider-managed keys. This\n * gives you greater control over key lifecycle, access policies, and audit logging.\n *\n * @example\n * ```typescript\n * // Create a CMEK for GCP\n * const cmek = Cmek.gcp(\n *   \"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key\"\n * );\n *\n * // Validate the resource name format\n * if (cmek.validatePattern()) {\n *   console.log(\"Valid CMEK format\");\n * }\n *\n * // Use in collection schema\n * const schema = new Schema();\n * schema.setCmek(cmek);\n * ```\n *\n * @note Pattern validation only checks format correctness. It does not verify\n * that the key exists or is accessible. Key permissions and access control\n * must be configured separately in your cloud provider's console.\n */\nexport class Cmek {\n  private static readonly GCP_PATTERN =\n    /^projects\\/.+\\/locations\\/.+\\/keyRings\\/.+\\/cryptoKeys\\/.+$/;\n\n  readonly provider: CmekProvider;\n  readonly resource: string;\n\n  private constructor(provider: CmekProvider, resource: string) {\n    this.provider = provider;\n    this.resource = resource;\n  }\n\n  /**\n   * Create a CMEK instance for Google Cloud Platform.\n   *\n   * @param resource - GCP Cloud KMS resource name in the format:\n   *   projects/{project-id}/locations/{location}/keyRings/{key-ring}/cryptoKeys/{key-name}\n   *\n   * @returns A new CMEK instance configured for GCP\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\n   *   \"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key\"\n   * );\n   * ```\n   */\n  static gcp(resource: string): Cmek {\n    return new Cmek(CmekProvider.GCP, resource);\n  }\n\n  /**\n   * Validate the CMEK resource name format.\n   *\n   * Validates that the resource name matches the expected pattern for the\n   * provider. This is a format check only and does not verify that the key\n   * exists or that you have access to it.\n   *\n   * For GCP, the expected format is:\n   *   projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}\n   *\n   * @returns true if the resource name format is valid, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\"projects/p/locations/l/keyRings/r/cryptoKeys/k\");\n   * cmek.validatePattern(); // Returns true\n   *\n   * const badCmek = Cmek.gcp(\"invalid-format\");\n   * badCmek.validatePattern(); // Returns false\n   * ```\n   */\n  validatePattern(): boolean {\n    if (this.provider === CmekProvider.GCP) {\n      return Cmek.GCP_PATTERN.test(this.resource);\n    }\n    return false;\n  }\n\n  /**\n   * Serialize CMEK to object format for API transport.\n   *\n   * Returns an object with the provider variant as the key and resource as the value.\n   *\n   * @returns Object containing the provider variant and resource identifier\n   *\n   * @example\n   * ```typescript\n   * const cmek = Cmek.gcp(\"projects/p/locations/l/keyRings/r/cryptoKeys/k\");\n   * cmek.toJSON();\n   * // Returns: { gcp: 'projects/p/locations/l/keyRings/r/cryptoKeys/k' }\n   * ```\n   */\n  toJSON(): Record<string, unknown> {\n    if (this.provider === CmekProvider.GCP) {\n      return { gcp: this.resource };\n    }\n    // Unreachable with current providers, but future-proof\n    throw new Error(`Unknown CMEK provider: ${this.provider}`);\n  }\n\n  /**\n   * Deserialize CMEK from object format.\n   *\n   * Expects the provider variant as the key and resource as the value.\n   *\n   * @param data - Object containing provider variant and resource\n   * @returns Deserialized CMEK instance\n   * @throws Error if the provider is unsupported or data is malformed\n   *\n   * @example\n   * ```typescript\n   * const data = { gcp: 'projects/p/locations/l/keyRings/r/cryptoKeys/k' };\n   * const cmek = Cmek.fromJSON(data);\n   * ```\n   */\n  static fromJSON(data: Record<string, unknown>): Cmek {\n    if (\"gcp\" in data && typeof data.gcp === \"string\") {\n      return Cmek.gcp(data.gcp);\n    }\n    throw new Error(\n      `Unsupported or missing CMEK provider in data: ${JSON.stringify(data)}`,\n    );\n  }\n}\n\nconst STRING_VALUE_NAME = \"string\";\nconst FLOAT_LIST_VALUE_NAME = \"float_list\";\nconst SPARSE_VECTOR_VALUE_NAME = \"sparse_vector\";\nconst INT_VALUE_NAME = \"int\";\nconst FLOAT_VALUE_NAME = \"float\";\nconst BOOL_VALUE_NAME = \"bool\";\n\nconst FTS_INDEX_NAME = \"fts_index\";\nconst STRING_INVERTED_INDEX_NAME = \"string_inverted_index\";\nconst VECTOR_INDEX_NAME = \"vector_index\";\nconst SPARSE_VECTOR_INDEX_NAME = \"sparse_vector_index\";\nconst INT_INVERTED_INDEX_NAME = \"int_inverted_index\";\nconst FLOAT_INVERTED_INDEX_NAME = \"float_inverted_index\";\nconst BOOL_INVERTED_INDEX_NAME = \"bool_inverted_index\";\n\nexport class FtsIndexConfig {\n  readonly type = \"FtsIndexConfig\";\n}\n\nexport class StringInvertedIndexConfig {\n  readonly type = \"StringInvertedIndexConfig\";\n}\n\nexport class IntInvertedIndexConfig {\n  readonly type = \"IntInvertedIndexConfig\";\n}\n\nexport class FloatInvertedIndexConfig {\n  readonly type = \"FloatInvertedIndexConfig\";\n}\n\nexport class BoolInvertedIndexConfig {\n  readonly type = \"BoolInvertedIndexConfig\";\n}\n\nexport interface VectorIndexConfigOptions {\n  space?: Space | null;\n  embeddingFunction?: EmbeddingFunction | null;\n  sourceKey?: string | Key | null;\n  hnsw?: ApiHnswIndexConfig | null;\n  spann?: ApiSpannIndexConfig | null;\n}\n\nexport class VectorIndexConfig {\n  readonly type = \"VectorIndexConfig\";\n  space: Space | null;\n  embeddingFunction?: EmbeddingFunction | null;\n  sourceKey: string | null;\n  hnsw: ApiHnswIndexConfig | null;\n  spann: ApiSpannIndexConfig | null;\n\n  constructor(options: VectorIndexConfigOptions = {}) {\n    this.space = options.space ?? null;\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey =\n      options.sourceKey instanceof Key\n        ? options.sourceKey.name\n        : options.sourceKey ?? null;\n    this.hnsw = options.hnsw ?? null;\n    this.spann = options.spann ?? null;\n  }\n}\n\nexport interface SparseVectorIndexConfigOptions {\n  embeddingFunction?: SparseEmbeddingFunction | null;\n  sourceKey?: string | Key | null;\n  bm25?: boolean | null;\n}\n\nexport class SparseVectorIndexConfig {\n  readonly type = \"SparseVectorIndexConfig\";\n  embeddingFunction?: SparseEmbeddingFunction | null;\n  sourceKey: string | null;\n  bm25: boolean | null;\n\n  constructor(options: SparseVectorIndexConfigOptions = {}) {\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey =\n      options.sourceKey instanceof Key\n        ? options.sourceKey.name\n        : options.sourceKey ?? null;\n    this.bm25 = options.bm25 ?? null;\n  }\n}\n\nexport class FtsIndexType {\n  constructor(public enabled: boolean, public config: FtsIndexConfig) {}\n}\n\nexport class StringInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: StringInvertedIndexConfig,\n  ) {}\n}\n\nexport class VectorIndexType {\n  constructor(public enabled: boolean, public config: VectorIndexConfig) {}\n}\n\nexport class SparseVectorIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: SparseVectorIndexConfig,\n  ) {}\n}\n\nexport class IntInvertedIndexType {\n  constructor(public enabled: boolean, public config: IntInvertedIndexConfig) {}\n}\n\nexport class FloatInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: FloatInvertedIndexConfig,\n  ) {}\n}\n\nexport class BoolInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: BoolInvertedIndexConfig,\n  ) {}\n}\n\nexport class StringValueType {\n  constructor(\n    public ftsIndex: FtsIndexType | null = null,\n    public stringInvertedIndex: StringInvertedIndexType | null = null,\n  ) {}\n}\n\nexport class FloatListValueType {\n  constructor(public vectorIndex: VectorIndexType | null = null) {}\n}\n\nexport class SparseVectorValueType {\n  constructor(public sparseVectorIndex: SparseVectorIndexType | null = null) {}\n}\n\nexport class IntValueType {\n  constructor(public intInvertedIndex: IntInvertedIndexType | null = null) {}\n}\n\nexport class FloatValueType {\n  constructor(\n    public floatInvertedIndex: FloatInvertedIndexType | null = null,\n  ) {}\n}\n\nexport class BoolValueType {\n  constructor(public boolInvertedIndex: BoolInvertedIndexType | null = null) {}\n}\n\nexport class ValueTypes {\n  string: StringValueType | null = null;\n  floatList: FloatListValueType | null = null;\n  sparseVector: SparseVectorValueType | null = null;\n  intValue: IntValueType | null = null;\n  floatValue: FloatValueType | null = null;\n  boolean: BoolValueType | null = null;\n}\n\nexport type IndexConfig =\n  | FtsIndexConfig\n  | VectorIndexConfig\n  | SparseVectorIndexConfig\n  | StringInvertedIndexConfig\n  | IntInvertedIndexConfig\n  | FloatInvertedIndexConfig\n  | BoolInvertedIndexConfig;\n\ntype ValueTypesJson = ApiValueTypes;\n\ntype JsonDict = Record<string, any>;\n\nconst cloneObject = <T>(value: T): T => {\n  if (value === null || value === undefined) {\n    return value;\n  }\n  if (typeof value !== \"object\") {\n    return value;\n  }\n  return Array.isArray(value)\n    ? (value.map((item) => cloneObject(item)) as T)\n    : (Object.fromEntries(\n        Object.entries(value as Record<string, unknown>).map(([k, v]) => [\n          k,\n          cloneObject(v),\n        ]),\n      ) as T);\n};\n\nconst resolveEmbeddingFunctionName = (\n  fn: AnyEmbeddingFunction | null | undefined,\n): string | undefined => {\n  if (!fn) return undefined;\n  if (typeof (fn as any).name === \"function\") {\n    try {\n      const value = (fn as any).name();\n      return typeof value === \"string\" ? value : undefined;\n    } catch (_err) {\n      return undefined;\n    }\n  }\n  if (typeof (fn as any).name === \"string\") {\n    return (fn as any).name;\n  }\n  return undefined;\n};\n\nconst prepareEmbeddingFunctionConfig = (\n  fn: AnyEmbeddingFunction | null | undefined,\n): EmbeddingFunctionConfiguration => {\n  if (!fn) {\n    return { type: \"legacy\" };\n  }\n\n  const name = resolveEmbeddingFunctionName(fn);\n  const getConfig =\n    typeof fn.getConfig === \"function\" ? fn.getConfig.bind(fn) : undefined;\n  const buildFromConfig = (fn.constructor as any)?.buildFromConfig;\n\n  if (!name || !getConfig || typeof buildFromConfig !== \"function\") {\n    return { type: \"legacy\" };\n  }\n\n  const config = getConfig();\n  if (typeof fn.validateConfig === \"function\") {\n    fn.validateConfig(config);\n  }\n\n  return {\n    type: \"known\",\n    name,\n    config,\n  };\n};\n\nconst ensureValueTypes = (\n  valueTypes: ValueTypes | null | undefined,\n): ValueTypes => valueTypes ?? new ValueTypes();\n\nconst ensureStringValueType = (valueTypes: ValueTypes): StringValueType => {\n  if (!valueTypes.string) {\n    valueTypes.string = new StringValueType();\n  }\n  return valueTypes.string;\n};\n\nconst ensureFloatListValueType = (\n  valueTypes: ValueTypes,\n): FloatListValueType => {\n  if (!valueTypes.floatList) {\n    valueTypes.floatList = new FloatListValueType();\n  }\n  return valueTypes.floatList;\n};\n\nconst ensureSparseVectorValueType = (\n  valueTypes: ValueTypes,\n): SparseVectorValueType => {\n  if (!valueTypes.sparseVector) {\n    valueTypes.sparseVector = new SparseVectorValueType();\n  }\n  return valueTypes.sparseVector;\n};\n\nconst ensureIntValueType = (valueTypes: ValueTypes): IntValueType => {\n  if (!valueTypes.intValue) {\n    valueTypes.intValue = new IntValueType();\n  }\n  return valueTypes.intValue;\n};\n\nconst ensureFloatValueType = (valueTypes: ValueTypes): FloatValueType => {\n  if (!valueTypes.floatValue) {\n    valueTypes.floatValue = new FloatValueType();\n  }\n  return valueTypes.floatValue;\n};\n\nconst ensureBoolValueType = (valueTypes: ValueTypes): BoolValueType => {\n  if (!valueTypes.boolean) {\n    valueTypes.boolean = new BoolValueType();\n  }\n  return valueTypes.boolean;\n};\n\n/**\n * Collection schema for configuring indexes and encryption.\n *\n * The schema controls how data is indexed and can optionally specify\n * customer-managed encryption keys (CMEK) for data at rest.\n *\n * @example\n * ```typescript\n * const schema = new Schema();\n * // Optionally add CMEK\n * schema.setCmek(Cmek.gcp(\"projects/p/locations/l/keyRings/r/cryptoKeys/k\"));\n * ```\n */\nexport class Schema {\n  defaults: ValueTypes;\n  keys: Record<string, ValueTypes>;\n  cmek: Cmek | null;\n\n  constructor() {\n    this.defaults = new ValueTypes();\n    this.keys = {};\n    this.cmek = null;\n    this.initializeDefaults();\n    this.initializeKeys();\n  }\n\n  /**\n   * Set the customer-managed encryption key for this collection.\n   *\n   * CMEK allows you to use your own encryption keys managed by cloud providers'\n   * key management services instead of default provider-managed keys.\n   *\n   * @param cmek - CMEK instance or null to remove encryption\n   * @returns this for method chaining\n   *\n   * @example\n   * ```typescript\n   * const schema = new Schema();\n   * schema.setCmek(Cmek.gcp(\n   *   \"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key\"\n   * ));\n   * ```\n   */\n  setCmek(cmek: Cmek | null): this {\n    this.cmek = cmek;\n    return this;\n  }\n\n  createIndex(config?: IndexConfig, key?: string): this {\n    const configProvided = config !== undefined && config !== null;\n    const keyProvided = key !== undefined && key !== null;\n\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot enable all index types globally. Must specify either config or key.\",\n      );\n    }\n\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot create index on special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    if (config instanceof VectorIndexConfig) {\n      if (!keyProvided) {\n        this.setVectorIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"Vector index cannot be enabled on specific keys. Use createIndex(config=VectorIndexConfig(...)) without specifying a key to configure the vector index globally.\",\n      );\n    }\n\n    if (config instanceof FtsIndexConfig) {\n      if (!keyProvided) {\n        this.setFtsIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"FTS index cannot be enabled on specific keys. Use createIndex(config=FtsIndexConfig(...)) without specifying a key to configure the FTS index globally.\",\n      );\n    }\n\n    if (config instanceof SparseVectorIndexConfig && !keyProvided) {\n      throw new Error(\n        \"Sparse vector index must be created on a specific key. Please specify a key using: createIndex(config=SparseVectorIndexConfig(...), key='your_key')\",\n      );\n    }\n\n    // TODO: Consider removing this check in the future to allow enabling all indexes for a key\n    // Disallow enabling all index types for a key (config=undefined, key=\"some_key\")\n    if (!configProvided && keyProvided && key) {\n      throw new Error(\n        `Cannot enable all index types for key '${key}'. Please specify a specific index configuration.`,\n      );\n    }\n\n    if (configProvided && !keyProvided) {\n      this.setIndexInDefaults(config as IndexConfig, true);\n    } else if (configProvided && keyProvided && key) {\n      this.setIndexForKey(key, config as IndexConfig, true);\n    }\n\n    return this;\n  }\n\n  deleteIndex(config?: IndexConfig, key?: string): this {\n    const configProvided = config !== undefined && config !== null;\n    const keyProvided = key !== undefined && key !== null;\n\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot disable all indexes. Must specify either config or key.\",\n      );\n    }\n\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot delete index on special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    if (config instanceof VectorIndexConfig) {\n      throw new Error(\"Deleting vector index is not currently supported.\");\n    }\n\n    if (config instanceof FtsIndexConfig) {\n      throw new Error(\"Deleting FTS index is not currently supported.\");\n    }\n\n    if (config instanceof SparseVectorIndexConfig) {\n      throw new Error(\n        \"Deleting sparse vector index is not currently supported.\",\n      );\n    }\n\n    // TODO: Consider removing this check in the future to allow disabling all indexes for a key\n    // Disallow disabling all index types for a key (config=undefined, key=\"some_key\")\n    if (keyProvided && !configProvided && key) {\n      throw new Error(\n        `Cannot disable all index types for key '${key}'. Please specify a specific index configuration.`,\n      );\n    }\n\n    if (keyProvided && configProvided && key) {\n      this.setIndexForKey(key, config as IndexConfig, false);\n    } else if (!keyProvided && configProvided) {\n      this.setIndexInDefaults(config as IndexConfig, false);\n    }\n\n    return this;\n  }\n\n  serializeToJSON(): InternalSchema {\n    const defaults = this.serializeValueTypes(this.defaults);\n\n    const keys: Record<string, ValueTypesJson> = {};\n    for (const [keyName, valueTypes] of Object.entries(this.keys)) {\n      keys[keyName] = this.serializeValueTypes(valueTypes);\n    }\n\n    const result: InternalSchema = {\n      defaults,\n      keys,\n    };\n\n    // Add CMEK if present\n    if (this.cmek !== null) {\n      result.cmek = this.cmek.toJSON();\n    }\n\n    return result;\n  }\n\n  static async deserializeFromJSON(\n    json: InternalSchema | JsonDict | null,\n    client: ChromaClient,\n  ): Promise<Schema | undefined> {\n    if (json == null) {\n      return undefined;\n    }\n\n    const data = json as JsonDict;\n    const instance = Object.create(Schema.prototype) as Schema;\n    instance.defaults = await Schema.deserializeValueTypes(\n      (data.defaults ?? {}) as Record<string, any>,\n      client,\n    );\n    instance.keys = {};\n    const keys = (data.keys ?? {}) as Record<string, Record<string, any>>;\n    for (const [keyName, value] of Object.entries(keys)) {\n      instance.keys[keyName] = await Schema.deserializeValueTypes(\n        value,\n        client,\n      );\n    }\n\n    // Deserialize CMEK if present\n    instance.cmek = null;\n    if (data.cmek && typeof data.cmek === \"object\") {\n      instance.cmek = Cmek.fromJSON(data.cmek as Record<string, unknown>);\n    }\n\n    return instance;\n  }\n\n  private setVectorIndexConfig(config: VectorIndexConfig): void {\n    const defaultsFloatList = ensureFloatListValueType(this.defaults);\n    const currentDefaultsVector =\n      defaultsFloatList.vectorIndex ??\n      new VectorIndexType(false, new VectorIndexConfig());\n    defaultsFloatList.vectorIndex = new VectorIndexType(\n      currentDefaultsVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: config.sourceKey ?? null,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null,\n      }),\n    );\n\n    const embeddingValueTypes = ensureValueTypes(this.keys[EMBEDDING_KEY]);\n    this.keys[EMBEDDING_KEY] = embeddingValueTypes;\n    const overrideFloatList = ensureFloatListValueType(embeddingValueTypes);\n    const currentOverrideVector =\n      overrideFloatList.vectorIndex ??\n      new VectorIndexType(\n        true,\n        new VectorIndexConfig({ sourceKey: DOCUMENT_KEY }),\n      );\n    const preservedSourceKey =\n      currentOverrideVector.config.sourceKey ?? DOCUMENT_KEY;\n    overrideFloatList.vectorIndex = new VectorIndexType(\n      currentOverrideVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: preservedSourceKey,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null,\n      }),\n    );\n  }\n\n  private setFtsIndexConfig(config: FtsIndexConfig): void {\n    const defaultsString = ensureStringValueType(this.defaults);\n    const currentDefaultsFts =\n      defaultsString.ftsIndex ?? new FtsIndexType(false, new FtsIndexConfig());\n    defaultsString.ftsIndex = new FtsIndexType(\n      currentDefaultsFts.enabled,\n      config,\n    );\n\n    const documentValueTypes = ensureValueTypes(this.keys[DOCUMENT_KEY]);\n    this.keys[DOCUMENT_KEY] = documentValueTypes;\n    const overrideString = ensureStringValueType(documentValueTypes);\n    const currentOverrideFts =\n      overrideString.ftsIndex ?? new FtsIndexType(true, new FtsIndexConfig());\n    overrideString.ftsIndex = new FtsIndexType(\n      currentOverrideFts.enabled,\n      config,\n    );\n  }\n\n  private setIndexInDefaults(config: IndexConfig, enabled: boolean): void {\n    if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(this.defaults);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(this.defaults);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(this.defaults);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(this.defaults);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(this.defaults);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n\n  private setIndexForKey(\n    key: string,\n    config: IndexConfig,\n    enabled: boolean,\n  ): void {\n    if (config instanceof SparseVectorIndexConfig && enabled) {\n      this.validateSingleSparseVectorIndex(key);\n      this.validateSparseVectorConfig(config);\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n\n    if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(current);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(current);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(current);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(current);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(current);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n\n  private enableAllIndexesForKey(key: string): void {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot enable all indexes for special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n    current.string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig()),\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(true, new VectorIndexConfig()),\n    );\n    // Sparse vector indexes require both sourceKey and embeddingFunction,\n    // so they cannot be auto-enabled and must be configured explicitly\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig()),\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()),\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private disableAllIndexesForKey(key: string): void {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot disable all indexes for special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n    current.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig()),\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig()),\n    );\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(false, new IntInvertedIndexConfig()),\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(false, new FloatInvertedIndexConfig()),\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(false, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private validateSingleSparseVectorIndex(targetKey: string): void {\n    for (const [existingKey, valueTypes] of Object.entries(this.keys)) {\n      if (existingKey === targetKey) continue;\n      const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n      if (sparseIndex?.enabled) {\n        throw new Error(\n          `Cannot enable sparse vector index on key '${targetKey}'. A sparse vector index is already enabled on key '${existingKey}'. Only one sparse vector index is allowed per collection.`,\n        );\n      }\n    }\n  }\n\n  private validateSparseVectorConfig(config: SparseVectorIndexConfig): void {\n    // Validate that if source_key is provided then embedding_function is also provided\n    // since there is no default embedding function\n    if (\n      config.sourceKey !== null &&\n      config.sourceKey !== undefined &&\n      !config.embeddingFunction\n    ) {\n      throw new Error(\n        `If sourceKey is provided then embeddingFunction must also be provided since there is no default embedding function. Config: ${JSON.stringify(\n          config,\n        )}`,\n      );\n    }\n  }\n\n  private initializeDefaults(): void {\n    this.defaults.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig()),\n    );\n\n    this.defaults.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig()),\n    );\n\n    this.defaults.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n\n    this.defaults.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig()),\n    );\n\n    this.defaults.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()),\n    );\n\n    this.defaults.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private initializeKeys(): void {\n    this.keys[DOCUMENT_KEY] = new ValueTypes();\n    this.keys[DOCUMENT_KEY].string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig()),\n    );\n\n    this.keys[EMBEDDING_KEY] = new ValueTypes();\n    this.keys[EMBEDDING_KEY].floatList = new FloatListValueType(\n      new VectorIndexType(\n        true,\n        new VectorIndexConfig({ sourceKey: DOCUMENT_KEY }),\n      ),\n    );\n  }\n\n  private serializeValueTypes(valueTypes: ValueTypes): ValueTypesJson {\n    const result: ValueTypesJson = {};\n\n    if (valueTypes.string) {\n      const serialized = this.serializeStringValueType(valueTypes.string);\n      if (Object.keys(serialized).length > 0) {\n        result[STRING_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.floatList) {\n      const serialized = this.serializeFloatListValueType(valueTypes.floatList);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_LIST_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.sparseVector) {\n      const serialized = this.serializeSparseVectorValueType(\n        valueTypes.sparseVector,\n      );\n      if (Object.keys(serialized).length > 0) {\n        result[SPARSE_VECTOR_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.intValue) {\n      const serialized = this.serializeIntValueType(valueTypes.intValue);\n      if (Object.keys(serialized).length > 0) {\n        result[INT_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.floatValue) {\n      const serialized = this.serializeFloatValueType(valueTypes.floatValue);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.boolean) {\n      const serialized = this.serializeBoolValueType(valueTypes.boolean);\n      if (Object.keys(serialized).length > 0) {\n        result[BOOL_VALUE_NAME] = serialized;\n      }\n    }\n\n    return result;\n  }\n\n  private serializeStringValueType(valueType: StringValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.ftsIndex) {\n      result[FTS_INDEX_NAME] = {\n        enabled: valueType.ftsIndex.enabled,\n        config: this.serializeConfig(valueType.ftsIndex.config),\n      };\n    }\n    if (valueType.stringInvertedIndex) {\n      result[STRING_INVERTED_INDEX_NAME] = {\n        enabled: valueType.stringInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.stringInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeFloatListValueType(valueType: FloatListValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.vectorIndex) {\n      result[VECTOR_INDEX_NAME] = {\n        enabled: valueType.vectorIndex.enabled,\n        config: this.serializeConfig(valueType.vectorIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeSparseVectorValueType(\n    valueType: SparseVectorValueType,\n  ): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.sparseVectorIndex) {\n      result[SPARSE_VECTOR_INDEX_NAME] = {\n        enabled: valueType.sparseVectorIndex.enabled,\n        config: this.serializeConfig(valueType.sparseVectorIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeIntValueType(valueType: IntValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.intInvertedIndex) {\n      result[INT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.intInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.intInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeFloatValueType(valueType: FloatValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.floatInvertedIndex) {\n      result[FLOAT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.floatInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.floatInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeBoolValueType(valueType: BoolValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.boolInvertedIndex) {\n      result[BOOL_INVERTED_INDEX_NAME] = {\n        enabled: valueType.boolInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.boolInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeConfig(config: IndexConfig): JsonDict {\n    if (config instanceof VectorIndexConfig) {\n      return this.serializeVectorConfig(config);\n    }\n    if (config instanceof SparseVectorIndexConfig) {\n      return this.serializeSparseVectorConfig(config);\n    }\n    return {};\n  }\n\n  private serializeVectorConfig(config: VectorIndexConfig): JsonDict {\n    const serialized: JsonDict = {};\n    const embeddingFunction = config.embeddingFunction;\n    const efConfig = prepareEmbeddingFunctionConfig(embeddingFunction);\n    serialized[\"embedding_function\"] = efConfig;\n\n    let resolvedSpace = config.space ?? null;\n    if (!resolvedSpace && embeddingFunction?.defaultSpace) {\n      resolvedSpace = embeddingFunction.defaultSpace();\n    }\n\n    if (\n      resolvedSpace &&\n      embeddingFunction?.supportedSpaces &&\n      !embeddingFunction.supportedSpaces().includes(resolvedSpace)\n    ) {\n      console.warn(\n        `Space '${resolvedSpace}' is not supported by embedding function '${\n          resolveEmbeddingFunctionName(embeddingFunction) ?? \"unknown\"\n        }'. Supported spaces: ${embeddingFunction\n          .supportedSpaces()\n          .join(\", \")}`,\n      );\n    }\n\n    if (resolvedSpace) {\n      serialized.space = resolvedSpace;\n    }\n\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n\n    if (config.hnsw) {\n      serialized.hnsw = cloneObject(config.hnsw);\n    }\n\n    if (config.spann) {\n      serialized.spann = cloneObject(config.spann);\n    }\n\n    return serialized;\n  }\n\n  private serializeSparseVectorConfig(\n    config: SparseVectorIndexConfig,\n  ): JsonDict {\n    const serialized: JsonDict = {};\n    const embeddingFunction = config.embeddingFunction;\n    serialized[\"embedding_function\"] =\n      prepareEmbeddingFunctionConfig(embeddingFunction);\n\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n\n    if (typeof config.bm25 === \"boolean\") {\n      serialized.bm25 = config.bm25;\n    }\n\n    return serialized;\n  }\n\n  private static async deserializeValueTypes(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<ValueTypes> {\n    const result = new ValueTypes();\n\n    if (json[STRING_VALUE_NAME]) {\n      result.string = Schema.deserializeStringValueType(\n        json[STRING_VALUE_NAME],\n      );\n    }\n\n    if (json[FLOAT_LIST_VALUE_NAME]) {\n      result.floatList = await Schema.deserializeFloatListValueType(\n        json[FLOAT_LIST_VALUE_NAME],\n        client,\n      );\n    }\n\n    if (json[SPARSE_VECTOR_VALUE_NAME]) {\n      result.sparseVector = await Schema.deserializeSparseVectorValueType(\n        json[SPARSE_VECTOR_VALUE_NAME],\n        client,\n      );\n    }\n\n    if (json[INT_VALUE_NAME]) {\n      result.intValue = Schema.deserializeIntValueType(json[INT_VALUE_NAME]);\n    }\n\n    if (json[FLOAT_VALUE_NAME]) {\n      result.floatValue = Schema.deserializeFloatValueType(\n        json[FLOAT_VALUE_NAME],\n      );\n    }\n\n    if (json[BOOL_VALUE_NAME]) {\n      result.boolean = Schema.deserializeBoolValueType(json[BOOL_VALUE_NAME]);\n    }\n\n    return result;\n  }\n\n  private static deserializeStringValueType(\n    json: Record<string, any>,\n  ): StringValueType {\n    let ftsIndex: FtsIndexType | null = null;\n    let stringIndex: StringInvertedIndexType | null = null;\n\n    if (json[FTS_INDEX_NAME]) {\n      const data = json[FTS_INDEX_NAME];\n      ftsIndex = new FtsIndexType(Boolean(data.enabled), new FtsIndexConfig());\n    }\n\n    if (json[STRING_INVERTED_INDEX_NAME]) {\n      const data = json[STRING_INVERTED_INDEX_NAME];\n      stringIndex = new StringInvertedIndexType(\n        Boolean(data.enabled),\n        new StringInvertedIndexConfig(),\n      );\n    }\n\n    return new StringValueType(ftsIndex, stringIndex);\n  }\n\n  private static async deserializeFloatListValueType(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<FloatListValueType> {\n    let vectorIndex: VectorIndexType | null = null;\n    if (json[VECTOR_INDEX_NAME]) {\n      const data = json[VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await Schema.deserializeVectorConfig(\n        data.config ?? {},\n        client,\n      );\n      vectorIndex = new VectorIndexType(enabled, config);\n    }\n    return new FloatListValueType(vectorIndex);\n  }\n\n  private static async deserializeSparseVectorValueType(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<SparseVectorValueType> {\n    let sparseIndex: SparseVectorIndexType | null = null;\n    if (json[SPARSE_VECTOR_INDEX_NAME]) {\n      const data = json[SPARSE_VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await Schema.deserializeSparseVectorConfig(\n        data.config ?? {},\n        client,\n      );\n      sparseIndex = new SparseVectorIndexType(enabled, config);\n    }\n    return new SparseVectorValueType(sparseIndex);\n  }\n\n  private static deserializeIntValueType(\n    json: Record<string, any>,\n  ): IntValueType {\n    let index: IntInvertedIndexType | null = null;\n    if (json[INT_INVERTED_INDEX_NAME]) {\n      const data = json[INT_INVERTED_INDEX_NAME];\n      index = new IntInvertedIndexType(\n        Boolean(data.enabled),\n        new IntInvertedIndexConfig(),\n      );\n    }\n    return new IntValueType(index);\n  }\n\n  private static deserializeFloatValueType(\n    json: Record<string, any>,\n  ): FloatValueType {\n    let index: FloatInvertedIndexType | null = null;\n    if (json[FLOAT_INVERTED_INDEX_NAME]) {\n      const data = json[FLOAT_INVERTED_INDEX_NAME];\n      index = new FloatInvertedIndexType(\n        Boolean(data.enabled),\n        new FloatInvertedIndexConfig(),\n      );\n    }\n    return new FloatValueType(index);\n  }\n\n  private static deserializeBoolValueType(\n    json: Record<string, any>,\n  ): BoolValueType {\n    let index: BoolInvertedIndexType | null = null;\n    if (json[BOOL_INVERTED_INDEX_NAME]) {\n      const data = json[BOOL_INVERTED_INDEX_NAME];\n      index = new BoolInvertedIndexType(\n        Boolean(data.enabled),\n        new BoolInvertedIndexConfig(),\n      );\n    }\n    return new BoolValueType(index);\n  }\n\n  private static async deserializeVectorConfig(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<VectorIndexConfig> {\n    const config = new VectorIndexConfig({\n      space: (json.space as Space | null | undefined) ?? null,\n      sourceKey: (json.source_key as string | null | undefined) ?? null,\n      hnsw: json.hnsw ? cloneObject(json.hnsw) : null,\n      spann: json.spann ? cloneObject(json.spann) : null,\n    });\n\n    config.embeddingFunction = await getEmbeddingFunction({\n      collectionName: \"schema deserialization\",\n      client,\n      efConfig: json.embedding_function as EmbeddingFunctionConfiguration,\n    });\n    if (!config.space && config.embeddingFunction?.defaultSpace) {\n      config.space = config.embeddingFunction.defaultSpace();\n    }\n\n    return config;\n  }\n\n  private static async deserializeSparseVectorConfig(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<SparseVectorIndexConfig> {\n    const config = new SparseVectorIndexConfig({\n      sourceKey: (json.source_key as string | null | undefined) ?? null,\n      bm25: typeof json.bm25 === \"boolean\" ? json.bm25 : null,\n    });\n\n    const embeddingFunction =\n      (await getSparseEmbeddingFunction(\n        \"schema deserialization\",\n        client,\n        json.embedding_function as EmbeddingFunctionConfiguration,\n      )) ??\n      (config.embeddingFunction as\n        | SparseEmbeddingFunction\n        | null\n        | undefined) ??\n      undefined;\n\n    config.embeddingFunction = embeddingFunction ?? null;\n    return config;\n  }\n\n  public resolveEmbeddingFunction(): EmbeddingFunction | null | undefined {\n    const embeddingOverride =\n      this.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config\n        .embeddingFunction;\n    if (embeddingOverride !== undefined) {\n      return embeddingOverride;\n    }\n    return this.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n  }\n}\n","import { ChromaClient } from \"./chroma-client\";\nimport {\n  EmbeddingFunction,\n  SparseEmbeddingFunction,\n} from \"./embedding-function\";\nimport {\n  BaseRecordSet,\n  CollectionMetadata,\n  GetResult,\n  IndexingStatus,\n  Metadata,\n  PreparedRecordSet,\n  PreparedInsertRecordSet,\n  QueryRecordSet,\n  QueryResult,\n  ReadLevel,\n  RecordSet,\n  Where,\n  WhereDocument,\n} from \"./types\";\nimport { Include, SparseVector, SearchPayload } from \"./api\";\nimport { DefaultService as Api } from \"./api\";\nimport {\n  validateRecordSetLengthConsistency,\n  validateIDs,\n  validateInclude,\n  validateBaseRecordSet,\n  validateWhere,\n  validateWhereDocument,\n  validateNResults,\n  validateMetadata,\n  validateMaxBatchSize,\n  embeddingsToBase64Bytes,\n  serializeMetadatas,\n  serializeMetadata,\n  deserializeMetadatas,\n  deserializeMetadataMatrix,\n  deserializeMetadata,\n} from \"./utils\";\nimport { createClient } from \"@hey-api/client-fetch\";\nimport { ChromaValueError } from \"./errors\";\nimport {\n  CollectionConfiguration,\n  processUpdateCollectionConfig,\n  UpdateCollectionConfiguration,\n} from \"./collection-configuration\";\nimport { SearchLike, SearchResult, toSearch } from \"./execution/expression\";\nimport { isPlainObject } from \"./execution/expression/common\";\nimport { Schema, EMBEDDING_KEY, DOCUMENT_KEY } from \"./schema\";\nimport type { SparseVectorIndexConfig } from \"./schema\";\n\n/**\n * Interface for collection operations using collection ID.\n * Provides methods for adding, querying, updating, and deleting records.\n */\nexport interface Collection {\n  /** Tenant name */\n  tenant: string;\n  /** Database name */\n  database: string;\n  /** Unique identifier for the collection */\n  id: string;\n  /** Name of the collection */\n  name: string;\n  /** Collection-level metadata */\n  metadata: CollectionMetadata | undefined;\n  /** Collection configuration settings */\n  configuration: CollectionConfiguration;\n  /** Optional embedding function. Must match the one used to create the collection. */\n  embeddingFunction?: EmbeddingFunction;\n  /** Collection schema describing index configuration */\n  schema?: Schema;\n  /** Gets the total number of records in the collection */\n  count(): Promise<number>;\n  /**\n   * Adds new records to the collection.\n   * @param args - Record data to add\n   */\n  add(args: {\n    /** Unique identifiers for the records */\n    ids: string[];\n    /** Optional pre-computed embeddings */\n    embeddings?: number[][];\n    /** Optional metadata for each record */\n    metadatas?: Metadata[];\n    /** Optional document text (will be embedded if embeddings not provided) */\n    documents?: string[];\n    /** Optional URIs for the records */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Retrieves records from the collection based on filters.\n   * @template TMeta - Type of metadata for type safety\n   * @param args - Query parameters for filtering records\n   * @returns Promise resolving to matching records\n   */\n  get<TMeta extends Metadata = Metadata>(args?: {\n    /** Specific record IDs to retrieve */\n    ids?: string[];\n    /** Metadata-based filtering conditions */\n    where?: Where;\n    /** Maximum number of records to return */\n    limit?: number;\n    /** Number of records to skip */\n    offset?: number;\n    /** Document content-based filtering conditions */\n    whereDocument?: WhereDocument;\n    /** Fields to include in the response */\n    include?: Include[];\n  }): Promise<GetResult<TMeta>>;\n  /**\n   * Retrieves a preview of records from the collection.\n   * @param args - Preview options\n   * @returns Promise resolving to a sample of records\n   */\n  peek(args: { limit?: number }): Promise<GetResult>;\n  /**\n   * Performs similarity search on the collection.\n   * @template TMeta - Type of metadata for type safety\n   * @param args - Query parameters for similarity search\n   * @returns Promise resolving to similar records ranked by distance\n   */\n  query<TMeta extends Metadata = Metadata>(args: {\n    /** Pre-computed query embedding vectors */\n    queryEmbeddings?: number[][];\n    /** Query text to be embedded and searched */\n    queryTexts?: string[];\n    /** Query URIs to be processed */\n    queryURIs?: string[];\n    /** Filter to specific record IDs */\n    ids?: string[];\n    /** Maximum number of results per query (default: 10) */\n    nResults?: number;\n    /** Metadata-based filtering conditions */\n    where?: Where;\n    /** Full-text search conditions */\n    whereDocument?: WhereDocument;\n    /** Fields to include in the response */\n    include?: Include[];\n  }): Promise<QueryResult<TMeta>>;\n  /**\n   * Modifies collection properties like name, metadata, or configuration.\n   * @param args - Properties to update\n   */\n  modify(args: {\n    /** New name for the collection */\n    name?: string;\n    /** New metadata for the collection */\n    metadata?: CollectionMetadata;\n    /** New configuration settings */\n    configuration?: UpdateCollectionConfiguration;\n  }): Promise<void>;\n  /**\n   * Creates a copy of the collection with a new name.\n   * @param args - Fork options\n   * @returns Promise resolving to the new Collection instance\n   */\n  fork({ name }: { name: string }): Promise<Collection>;\n  /**\n   * Updates existing records in the collection.\n   * @param args - Record data to update\n   */\n  update(args: {\n    /** IDs of records to update */\n    ids: string[];\n    /** New embedding vectors */\n    embeddings?: number[][];\n    /** New metadata */\n    metadatas?: Metadata[];\n    /** New document text */\n    documents?: string[];\n    /** New URIs */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Inserts new records or updates existing ones (upsert operation).\n   * @param args - Record data to upsert\n   */\n  upsert(args: {\n    /** IDs of records to upsert */\n    ids: string[];\n    /** Embedding vectors */\n    embeddings?: number[][];\n    /** Metadata */\n    metadatas?: Metadata[];\n    /** Document text */\n    documents?: string[];\n    /** URIs */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Deletes records from the collection based on filters.\n   * @param args - Deletion criteria\n   */\n  delete(args: {\n    /** Specific record IDs to delete */\n    ids?: string[];\n    /** Metadata-based filtering for deletion */\n    where?: Where;\n    /** Document content-based filtering for deletion */\n    whereDocument?: WhereDocument;\n  }): Promise<void>;\n  /**\n   * Performs hybrid search on the collection using expression builders.\n   * @param searches - Single search payload or array of payloads\n   * @returns Promise resolving to column-major search results\n   */\n  search(\n    searches: SearchLike | SearchLike[],\n    options?: {\n      /**\n       * Controls whether to read from the write-ahead log.\n       * - ReadLevel.INDEX_AND_WAL: Read from both index and WAL (default)\n       * - ReadLevel.INDEX_ONLY: Read only from index, faster but recent writes may not be visible\n       */\n      readLevel?: ReadLevel;\n    },\n  ): Promise<SearchResult>;\n  /**\n   * Gets the indexing status of the collection.\n   * @returns Promise resolving to indexing status information\n   */\n  getIndexingStatus(): Promise<IndexingStatus>;\n}\n\n/**\n * Arguments for creating a Collection instance.\n */\nexport interface CollectionArgs {\n  /** ChromaDB client instance */\n  chromaClient: ChromaClient;\n  /** HTTP API client */\n  apiClient: ReturnType<typeof createClient>;\n  /** Collection name */\n  name: string;\n  /** Collection ID */\n  id: string;\n  /** Tenant name */\n  tenant: string;\n  /** Database name */\n  database: string;\n  /** Embedding function for the collection */\n  embeddingFunction?: EmbeddingFunction;\n  /** Collection configuration */\n  configuration: CollectionConfiguration;\n  /** Optional collection metadata */\n  metadata?: CollectionMetadata;\n  /** Optional schema returned by the server */\n  schema?: Schema;\n}\n\n/**\n * Implementation of CollectionAPI for ID-based collection operations.\n * Provides core functionality for interacting with collections using their ID.\n */\nexport class CollectionImpl implements Collection {\n  protected readonly chromaClient: ChromaClient;\n  protected readonly apiClient: ReturnType<typeof createClient>;\n  public readonly id: string;\n  public readonly tenant: string;\n  public readonly database: string;\n  private _name: string;\n  private _metadata: CollectionMetadata | undefined;\n  private _configuration: CollectionConfiguration;\n  protected _embeddingFunction: EmbeddingFunction | undefined;\n  protected _schema: Schema | undefined;\n\n  /**\n   * Creates a new CollectionAPIImpl instance.\n   * @param options - Configuration for the collection API\n   */\n  constructor({\n    chromaClient,\n    apiClient,\n    id,\n    tenant,\n    database,\n    name,\n    metadata,\n    configuration,\n    embeddingFunction,\n    schema,\n  }: CollectionArgs) {\n    this.chromaClient = chromaClient;\n    this.apiClient = apiClient;\n    this.id = id;\n    this.tenant = tenant;\n    this.database = database;\n    this._name = name;\n    this._metadata = metadata;\n    this._configuration = configuration;\n    this._embeddingFunction = embeddingFunction;\n    this._schema = schema;\n  }\n\n  public get name(): string {\n    return this._name;\n  }\n\n  private set name(name: string) {\n    this._name = name;\n  }\n\n  public get configuration(): CollectionConfiguration {\n    return this._configuration;\n  }\n\n  private set configuration(configuration: CollectionConfiguration) {\n    this._configuration = configuration;\n  }\n\n  public get metadata(): CollectionMetadata | undefined {\n    return this._metadata;\n  }\n\n  private set metadata(metadata: CollectionMetadata | undefined) {\n    this._metadata = metadata;\n  }\n\n  public get embeddingFunction(): EmbeddingFunction | undefined {\n    return this._embeddingFunction;\n  }\n\n  protected set embeddingFunction(\n    embeddingFunction: EmbeddingFunction | undefined,\n  ) {\n    this._embeddingFunction = embeddingFunction;\n  }\n\n  public get schema(): Schema | undefined {\n    return this._schema;\n  }\n\n  protected set schema(schema: Schema | undefined) {\n    this._schema = schema;\n  }\n\n  protected async path(): Promise<{\n    tenant: string;\n    database: string;\n    collection_id: string;\n  }> {\n    return {\n      tenant: this.tenant,\n      database: this.database,\n      collection_id: this.id,\n    };\n  }\n\n  private async embed(inputs: string[], isQuery: boolean): Promise<number[][]> {\n    const embeddingFunction =\n      this._embeddingFunction ?? this.getSchemaEmbeddingFunction();\n\n    if (!embeddingFunction) {\n      throw new ChromaValueError(\n        \"Embedding function must be defined for operations requiring embeddings.\",\n      );\n    }\n\n    if (isQuery && embeddingFunction.generateForQueries) {\n      return await embeddingFunction.generateForQueries(inputs);\n    }\n\n    return await embeddingFunction.generate(inputs);\n  }\n\n  private async sparseEmbed(\n    sparseEmbeddingFunction: SparseEmbeddingFunction,\n    inputs: string[],\n    isQuery: boolean,\n  ): Promise<SparseVector[]> {\n    if (isQuery && sparseEmbeddingFunction.generateForQueries) {\n      return await sparseEmbeddingFunction.generateForQueries(inputs);\n    }\n\n    return await sparseEmbeddingFunction.generate(inputs);\n  }\n\n  private getSparseEmbeddingTargets(): Record<string, SparseVectorIndexConfig> {\n    const schema = this._schema;\n    if (!schema) return {};\n\n    const targets: Record<string, SparseVectorIndexConfig> = {};\n    for (const [key, valueTypes] of Object.entries(schema.keys)) {\n      const sparseVector = valueTypes.sparseVector;\n      const sparseIndex = sparseVector?.sparseVectorIndex;\n      if (!sparseIndex?.enabled) continue;\n\n      const config = sparseIndex.config;\n      if (!config.embeddingFunction || !config.sourceKey) continue;\n\n      targets[key] = config;\n    }\n\n    return targets;\n  }\n\n  private async applySparseEmbeddingsToMetadatas(\n    metadatas?: Metadata[],\n    documents?: string[],\n  ): Promise<Metadata[] | undefined> {\n    const sparseTargets = this.getSparseEmbeddingTargets();\n    if (Object.keys(sparseTargets).length === 0) {\n      return metadatas;\n    }\n\n    // If no metadatas provided, create empty objects based on documents length\n    if (!metadatas) {\n      if (!documents) {\n        return undefined;\n      }\n      metadatas = Array(documents.length)\n        .fill(null)\n        .map(() => ({}));\n    }\n\n    // Create copies, converting null to empty object\n    const updatedMetadatas = metadatas.map((metadata) =>\n      metadata !== null && metadata !== undefined ? { ...metadata } : {},\n    );\n    const documentsList = documents ? [...documents] : undefined;\n\n    for (const [targetKey, config] of Object.entries(sparseTargets)) {\n      const sourceKey = config.sourceKey;\n      const embeddingFunction = config.embeddingFunction;\n      if (!sourceKey || !embeddingFunction) {\n        continue;\n      }\n\n      const inputs: string[] = [];\n      const positions: number[] = [];\n\n      // Handle special case: source_key is \"#document\"\n      if (sourceKey === DOCUMENT_KEY) {\n        if (!documentsList) {\n          continue;\n        }\n\n        // Collect documents that need embedding\n        updatedMetadatas.forEach((metadata, index) => {\n          // Skip if target already exists in metadata\n          if (targetKey in metadata) {\n            return;\n          }\n\n          // Get document at this position\n          if (index < documentsList.length) {\n            const doc = documentsList[index];\n            if (typeof doc === \"string\") {\n              inputs.push(doc);\n              positions.push(index);\n            }\n          }\n        });\n\n        // Generate embeddings for all collected documents\n        if (inputs.length === 0) {\n          continue;\n        }\n\n        const sparseEmbeddings = await this.sparseEmbed(\n          embeddingFunction,\n          inputs,\n          false,\n        );\n        if (sparseEmbeddings.length !== positions.length) {\n          throw new ChromaValueError(\n            \"Sparse embedding function returned unexpected number of embeddings.\",\n          );\n        }\n\n        positions.forEach((position, idx) => {\n          updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];\n        });\n\n        continue; // Skip the metadata-based logic below\n      }\n\n      // Handle normal case: source_key is a metadata field\n      updatedMetadatas.forEach((metadata, index) => {\n        if (targetKey in metadata) {\n          return;\n        }\n\n        const sourceValue = metadata[sourceKey];\n        if (typeof sourceValue !== \"string\") {\n          return;\n        }\n\n        inputs.push(sourceValue);\n        positions.push(index);\n      });\n\n      if (inputs.length === 0) {\n        continue;\n      }\n\n      const sparseEmbeddings = await this.sparseEmbed(\n        embeddingFunction,\n        inputs,\n        false,\n      );\n      if (sparseEmbeddings.length !== positions.length) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\",\n        );\n      }\n\n      positions.forEach((position, idx) => {\n        updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];\n      });\n    }\n\n    // Convert empty objects back to null\n    const resultMetadatas = updatedMetadatas.map((metadata) =>\n      Object.keys(metadata).length === 0 ? null : metadata,\n    );\n\n    return resultMetadatas as Metadata[];\n  }\n\n  private async embedKnnLiteral(\n    knn: Record<string, unknown>,\n  ): Promise<Record<string, unknown>> {\n    const queryValue = knn.query as unknown;\n    if (typeof queryValue !== \"string\") {\n      return { ...knn };\n    }\n\n    const keyValue = knn.key as unknown;\n    const key = typeof keyValue === \"string\" ? keyValue : EMBEDDING_KEY;\n\n    if (key === EMBEDDING_KEY) {\n      const embeddings = await this.embed([queryValue], true);\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\",\n        );\n      }\n      return { ...knn, query: embeddings[0] };\n    }\n\n    const schema = this._schema;\n    if (!schema) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': schema is not available. Provide an embedded vector or configure an embedding function.`,\n      );\n    }\n\n    const valueTypes = schema.keys[key];\n    if (!valueTypes) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': key not found in schema. Provide an embedded vector or configure an embedding function.`,\n      );\n    }\n\n    const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n    if (sparseIndex?.enabled && sparseIndex.config.embeddingFunction) {\n      const sparseEmbeddingFunction = sparseIndex.config.embeddingFunction;\n      const sparseEmbeddings = await this.sparseEmbed(\n        sparseEmbeddingFunction,\n        [queryValue],\n        true,\n      );\n      if (!sparseEmbeddings || sparseEmbeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\",\n        );\n      }\n      return { ...knn, query: sparseEmbeddings[0] };\n    }\n\n    const vectorIndex = valueTypes.floatList?.vectorIndex;\n    if (vectorIndex?.enabled && vectorIndex.config.embeddingFunction) {\n      const embeddingFunction = vectorIndex.config.embeddingFunction;\n      const embeddings = embeddingFunction.generateForQueries\n        ? await embeddingFunction.generateForQueries([queryValue])\n        : await embeddingFunction.generate([queryValue]);\n\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\",\n        );\n      }\n\n      return { ...knn, query: embeddings[0] };\n    }\n\n    throw new ChromaValueError(\n      `Cannot embed string query for key '${key}': no embedding function configured. Provide an embedded vector or configure an embedding function.`,\n    );\n  }\n\n  private async embedRankLiteral(rank: unknown): Promise<unknown> {\n    if (rank === null || rank === undefined) {\n      return rank;\n    }\n\n    if (Array.isArray(rank)) {\n      return Promise.all(rank.map((item) => this.embedRankLiteral(item)));\n    }\n\n    if (!isPlainObject(rank)) {\n      return rank;\n    }\n\n    const entries = await Promise.all(\n      Object.entries(rank).map(async ([key, value]) => {\n        if (key === \"$knn\" && isPlainObject(value)) {\n          return [key, await this.embedKnnLiteral(value)];\n        }\n        return [key, await this.embedRankLiteral(value)];\n      }),\n    );\n\n    return Object.fromEntries(entries);\n  }\n\n  private async embedSearchPayload(\n    payload: SearchPayload,\n  ): Promise<SearchPayload> {\n    if (!payload.rank) {\n      return payload;\n    }\n\n    const embeddedRank = await this.embedRankLiteral(payload.rank);\n    if (!isPlainObject(embeddedRank)) {\n      return payload;\n    }\n\n    return {\n      ...payload,\n      rank: embeddedRank as SearchPayload[\"rank\"],\n    };\n  }\n\n  private getSchemaEmbeddingFunction(): EmbeddingFunction | undefined {\n    const schema = this._schema;\n    if (!schema) return undefined;\n\n    const schemaOverride = schema.keys[EMBEDDING_KEY];\n    const overrideFunction =\n      schemaOverride?.floatList?.vectorIndex?.config.embeddingFunction;\n    if (overrideFunction) {\n      return overrideFunction;\n    }\n\n    const defaultFunction =\n      schema.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n    return defaultFunction ?? undefined;\n  }\n\n  private async prepareRecords<T extends boolean = false>({\n    recordSet,\n    update = false as T,\n  }: {\n    recordSet: RecordSet;\n    update?: T;\n  }): Promise<T extends true ? PreparedRecordSet : PreparedInsertRecordSet> {\n    const maxBatchSize = await this.chromaClient.getMaxBatchSize();\n\n    validateRecordSetLengthConsistency(recordSet);\n    validateIDs(recordSet.ids);\n    validateBaseRecordSet({ recordSet, update });\n    validateMaxBatchSize(recordSet.ids.length, maxBatchSize);\n\n    if (!recordSet.embeddings && recordSet.documents) {\n      recordSet.embeddings = await this.embed(recordSet.documents, false);\n    }\n\n    const metadatasWithSparse = await this.applySparseEmbeddingsToMetadatas(\n      recordSet.metadatas,\n      recordSet.documents,\n    );\n\n    const preparedRecordSet: PreparedRecordSet = {\n      ...recordSet,\n      metadatas: metadatasWithSparse,\n    };\n\n    const base64Supported = await this.chromaClient.supportsBase64Encoding();\n    if (base64Supported && recordSet.embeddings) {\n      preparedRecordSet.embeddings = embeddingsToBase64Bytes(\n        recordSet.embeddings,\n      );\n    }\n\n    return preparedRecordSet as T extends true\n      ? PreparedRecordSet\n      : PreparedInsertRecordSet;\n  }\n\n  private validateGet(\n    include: Include[],\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n  ) {\n    validateInclude({ include, exclude: [\"distances\"] });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n\n  private async prepareQuery(\n    recordSet: BaseRecordSet,\n    include: Include[],\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n    nResults?: number,\n  ): Promise<QueryRecordSet> {\n    validateBaseRecordSet({\n      recordSet,\n      embeddingsField: \"queryEmbeddings\",\n      documentsField: \"queryTexts\",\n    });\n    validateInclude({ include });\n\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n    if (nResults) validateNResults(nResults);\n\n    let embeddings: number[][];\n    if (!recordSet.embeddings) {\n      embeddings = await this.embed(recordSet.documents!, true);\n    } else {\n      embeddings = recordSet.embeddings;\n    }\n\n    return {\n      ...recordSet,\n      ids,\n      embeddings,\n    };\n  }\n\n  private validateDelete(\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n  ) {\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n\n  public async count(): Promise<number> {\n    const { data } = await Api.collectionCount({\n      client: this.apiClient,\n      path: await this.path(),\n    });\n\n    return data;\n  }\n\n  public async add({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }) {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({ recordSet });\n\n    await Api.collectionAdd({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        documents: preparedRecordSet.documents,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n      },\n    });\n  }\n\n  public async get<TMeta extends Metadata = Metadata>(\n    args: Partial<{\n      ids?: string[];\n      where?: Where;\n      limit?: number;\n      offset?: number;\n      whereDocument?: WhereDocument;\n      include?: Include[];\n    }> = {},\n  ): Promise<GetResult<TMeta>> {\n    const {\n      ids,\n      where,\n      limit,\n      offset,\n      whereDocument,\n      include = [\"documents\", \"metadatas\"],\n    } = args;\n\n    this.validateGet(include, ids, where, whereDocument);\n\n    const { data } = await Api.collectionGet({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        limit,\n        offset,\n        where_document: whereDocument,\n        include,\n      },\n    });\n\n    const deserializedMetadatas = deserializeMetadatas(data.metadatas) ?? [];\n\n    return new GetResult<TMeta>({\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids,\n      include: data.include,\n      metadatas: deserializedMetadatas as (TMeta | null)[],\n      uris: data.uris ?? [],\n    });\n  }\n\n  public async peek({ limit = 10 }: { limit?: number }): Promise<GetResult> {\n    return this.get({ limit });\n  }\n\n  public async query<TMeta extends Metadata = Metadata>({\n    queryEmbeddings,\n    queryTexts,\n    queryURIs,\n    ids,\n    nResults = 10,\n    where,\n    whereDocument,\n    include = [\"metadatas\", \"documents\", \"distances\"],\n  }: {\n    queryEmbeddings?: number[][];\n    queryTexts?: string[];\n    queryURIs?: string[];\n    ids?: string[];\n    nResults?: number;\n    where?: Where;\n    whereDocument?: WhereDocument;\n    include?: Include[];\n  }): Promise<QueryResult<TMeta>> {\n    const recordSet: BaseRecordSet = {\n      embeddings: queryEmbeddings,\n      documents: queryTexts,\n      uris: queryURIs,\n    };\n\n    const queryRecordSet = await this.prepareQuery(\n      recordSet,\n      include,\n      ids,\n      where,\n      whereDocument,\n      nResults,\n    );\n\n    const { data } = await Api.collectionQuery({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: queryRecordSet.ids,\n        include,\n        n_results: nResults,\n        query_embeddings: queryRecordSet.embeddings,\n        where,\n        where_document: whereDocument,\n      },\n    });\n\n    const deserializedMetadatas =\n      deserializeMetadataMatrix(data.metadatas) ?? [];\n\n    return new QueryResult({\n      distances: data.distances ?? [],\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids ?? [],\n      include: data.include,\n      metadatas: deserializedMetadatas as (TMeta | null)[][],\n      uris: data.uris ?? [],\n    });\n  }\n\n  public async search(\n    searches: SearchLike | SearchLike[],\n    options?: {\n      readLevel?: ReadLevel;\n    },\n  ): Promise<SearchResult> {\n    const items = Array.isArray(searches) ? searches : [searches];\n\n    if (items.length === 0) {\n      throw new ChromaValueError(\n        \"At least one search payload must be provided.\",\n      );\n    }\n\n    const payloads = await Promise.all(\n      items.map(async (search) => {\n        const payload = toSearch(search).toPayload();\n        return this.embedSearchPayload(payload);\n      }),\n    );\n\n    const { data } = await Api.collectionSearch({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        searches: payloads,\n        read_level: options?.readLevel,\n      },\n    });\n\n    return new SearchResult(data);\n  }\n\n  public async modify({\n    name,\n    metadata,\n    configuration,\n  }: {\n    name?: string;\n    metadata?: CollectionMetadata;\n    configuration?: UpdateCollectionConfiguration;\n  }): Promise<void> {\n    if (name) this.name = name;\n\n    if (metadata) {\n      validateMetadata(metadata);\n      this.metadata = metadata;\n    }\n\n    const { updateConfiguration, updateEmbeddingFunction } = configuration\n      ? await processUpdateCollectionConfig({\n          collectionName: this.name,\n          currentConfiguration: this.configuration,\n          newConfiguration: configuration,\n          currentEmbeddingFunction: this.embeddingFunction,\n          client: this.chromaClient,\n        })\n      : {};\n\n    if (updateEmbeddingFunction) {\n      this.embeddingFunction = updateEmbeddingFunction;\n    }\n\n    if (updateConfiguration) {\n      this.configuration = {\n        hnsw: { ...this.configuration.hnsw, ...updateConfiguration.hnsw },\n        spann: { ...this.configuration.spann, ...updateConfiguration.spann },\n        embeddingFunction: updateConfiguration.embedding_function,\n      };\n    }\n\n    await Api.updateCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        new_name: name,\n        new_metadata: serializeMetadata(metadata),\n        new_configuration: updateConfiguration,\n      },\n    });\n  }\n\n  public async fork({ name }: { name: string }): Promise<Collection> {\n    const { data } = await Api.forkCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { new_name: name },\n    });\n\n    return new CollectionImpl({\n      chromaClient: this.chromaClient,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: this.tenant,\n      database: this.database,\n      id: data.id,\n      embeddingFunction: this._embeddingFunction,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      configuration: data.configuration_json,\n    });\n  }\n\n  public async update({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }): Promise<void> {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n      update: true,\n    });\n\n    await Api.collectionUpdate({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents,\n      },\n    });\n  }\n\n  public async upsert({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }): Promise<void> {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n    });\n\n    await Api.collectionUpsert({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents,\n      },\n    });\n  }\n\n  public async delete({\n    ids,\n    where,\n    whereDocument,\n  }: {\n    ids?: string[];\n    where?: Where;\n    whereDocument?: WhereDocument;\n  }): Promise<void> {\n    this.validateDelete(ids, where, whereDocument);\n\n    await Api.collectionDelete({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        where_document: whereDocument,\n      },\n    });\n  }\n\n  public async getIndexingStatus(): Promise<IndexingStatus> {\n    const { data } = await Api.indexingStatus({\n      client: this.apiClient,\n      path: await this.path(),\n    });\n\n    return data;\n  }\n}\n","export function withChroma(userNextConfig: any = {}): any {\n  const originalWebpackFunction = userNextConfig.webpack;\n\n  const newWebpackFunction = (config: any, options: any): any => {\n    if (!Array.isArray(config.externals)) {\n      config.externals = [];\n    }\n\n    const externalsToAdd = [\"@huggingface/transformers\", \"chromadb\"];\n    for (const ext of externalsToAdd) {\n      if (!config.externals.includes(ext)) {\n        config.externals.push(ext);\n      }\n    }\n\n    if (typeof originalWebpackFunction === \"function\") {\n      return originalWebpackFunction(config, options);\n    }\n    return config;\n  };\n\n  return {\n    ...userNextConfig,\n    webpack: newWebpackFunction,\n  };\n}\n","import {\n  ChromaClientError,\n  ChromaConnectionError,\n  ChromaError,\n  ChromaForbiddenError,\n  ChromaNotFoundError,\n  ChromaQuotaExceededError,\n  ChromaRateLimitError,\n  ChromaServerError,\n  ChromaUnauthorizedError,\n  ChromaUniqueError,\n} from \"./errors\";\n\nconst offlineError = (error: any): boolean => {\n  return Boolean(\n    (error?.name === \"TypeError\" || error?.name === \"FetchError\") &&\n      (error.message?.includes(\"fetch failed\") ||\n        error.message?.includes(\"Failed to fetch\") ||\n        error.message?.includes(\"ENOTFOUND\")),\n  );\n};\n\nconst getErrorMessage = async (response: Response): Promise<string> => {\n  try {\n    const body = await response.clone().json();\n    return (\n      body.message || body.error || `${response.status}: ${response.statusText}`\n    );\n  } catch {\n    return `${response.status}: ${response.statusText}`;\n  }\n};\n\nexport const chromaFetch: typeof fetch = async (input, init) => {\n  let response: Response;\n  try {\n    response = await fetch(input, init);\n  } catch (err) {\n    if (offlineError(err)) {\n      throw new ChromaConnectionError(\n        \"Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.\",\n      );\n    }\n    throw new ChromaConnectionError(\"Failed to connect to Chroma\");\n  }\n\n  if (response.ok) {\n    return response;\n  }\n\n  switch (response.status) {\n    case 400:\n      let status = \"Bad Request\";\n      try {\n        const responseBody = await response.json();\n        status = responseBody.message || status;\n      } catch {}\n      throw new ChromaClientError(\n        `Bad request to ${\n          (input as Request).url || \"Chroma\"\n        } with status: ${status}`,\n      );\n    case 401:\n      throw new ChromaUnauthorizedError(`Unauthorized`);\n    case 403:\n      throw new ChromaForbiddenError(\n        `You do not have permission to access the requested resource.`,\n      );\n    case 404:\n      throw new ChromaNotFoundError(\n        `The requested resource could not be found`,\n      );\n    case 409:\n      throw new ChromaUniqueError(\"The resource already exists\");\n    case 422:\n      try {\n        const body = await response.json();\n        if (\n          body &&\n          body.message &&\n          (body.message.startsWith(\"Quota exceeded\") ||\n            body.message.startsWith(\"Billing limit exceeded\"))\n        ) {\n          throw new ChromaQuotaExceededError(body?.message);\n        }\n        throw new ChromaClientError(body?.message || \"Unprocessable Entity\");\n      } catch (error) {\n        if (\n          error instanceof ChromaQuotaExceededError ||\n          error instanceof ChromaClientError\n        ) {\n          throw error;\n        }\n        throw new ChromaClientError(\n          `Unprocessable Entity: ${response.statusText}`,\n        );\n      }\n    case 429:\n      throw new ChromaRateLimitError(\"Rate limit exceeded\");\n  }\n\n  const errorMessage = await getErrorMessage(response);\n  throw new ChromaServerError(errorMessage);\n};\n","import { defaultAdminClientArgs, HttpMethod, normalizeMethod } from \"./utils\";\nimport { createClient, createConfig } from \"@hey-api/client-fetch\";\nimport { Database, DefaultService as Api } from \"./api\";\nimport { chromaFetch } from \"./chroma-fetch\";\n\n/**\n * Configuration options for the AdminClient.\n */\nexport interface AdminClientArgs {\n  /** The host address of the Chroma server */\n  host: string;\n  /** The port number of the Chroma server */\n  port: number;\n  /** Whether to use SSL/HTTPS for connections */\n  ssl: boolean;\n  /** Additional HTTP headers to send with requests */\n  headers?: Record<string, string>;\n  /** Additional fetch options for HTTP requests */\n  fetchOptions?: RequestInit;\n}\n\n/**\n * Arguments for listing databases within a tenant.\n */\nexport interface ListDatabasesArgs {\n  /** The tenant name to list databases for */\n  tenant: string;\n  /** Maximum number of databases to return (default: 100) */\n  limit?: number;\n  /** Number of databases to skip (default: 0) */\n  offset?: number;\n}\n\n/**\n * Administrative client for managing ChromaDB tenants and databases.\n * Provides methods for creating, deleting, and listing tenants and databases.\n */\nexport class AdminClient {\n  private readonly apiClient: ReturnType<typeof createClient>;\n\n  /**\n   * Creates a new AdminClient instance.\n   * @param args - Optional configuration for the admin client\n   */\n  constructor(args?: AdminClientArgs) {\n    const { host, port, ssl, headers, fetchOptions } =\n      args || defaultAdminClientArgs;\n\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method) as HttpMethod,\n      baseUrl,\n      headers,\n    };\n\n    this.apiClient = createClient(createConfig(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n\n  /**\n   * Creates a new database within a tenant.\n   * @param options - Database creation options\n   * @param options.name - Name of the database to create\n   * @param options.tenant - Tenant that will own the database\n   */\n  public async createDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<void> {\n    await Api.createDatabase({\n      client: this.apiClient,\n      path: { tenant },\n      body: { name },\n    });\n  }\n\n  /**\n   * Retrieves information about a specific database.\n   * @param options - Database retrieval options\n   * @param options.name - Name of the database to retrieve\n   * @param options.tenant - Tenant that owns the database\n   * @returns Promise resolving to database information\n   */\n  public async getDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<Database> {\n    const { data } = await Api.getDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name },\n    });\n\n    return data;\n  }\n\n  /**\n   * Deletes a database and all its data.\n   * @param options - Database deletion options\n   * @param options.name - Name of the database to delete\n   * @param options.tenant - Tenant that owns the database\n   * @warning This operation is irreversible and will delete all data\n   */\n  public async deleteDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<void> {\n    await Api.deleteDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name },\n    });\n  }\n\n  /**\n   * Lists all databases within a tenant.\n   * @param args - Listing parameters including tenant and pagination\n   * @returns Promise resolving to an array of database information\n   */\n  public async listDatabases(args: ListDatabasesArgs): Promise<Database[]> {\n    const { limit = 100, offset = 0, tenant } = args;\n    const { data } = await Api.listDatabases({\n      client: this.apiClient,\n      path: { tenant },\n      query: { limit, offset },\n    });\n\n    return data;\n  }\n\n  /**\n   * Creates a new tenant.\n   * @param options - Tenant creation options\n   * @param options.name - Name of the tenant to create\n   */\n  public async createTenant({ name }: { name: string }): Promise<void> {\n    await Api.createTenant({\n      client: this.apiClient,\n      body: { name },\n    });\n  }\n\n  /**\n   * Retrieves information about a specific tenant.\n   * @param options - Tenant retrieval options\n   * @param options.name - Name of the tenant to retrieve\n   * @returns Promise resolving to the tenant name\n   */\n  public async getTenant({ name }: { name: string }): Promise<string> {\n    const { data } = await Api.getTenant({\n      client: this.apiClient,\n      path: { tenant_name: name },\n    });\n\n    return data.name;\n  }\n}\n","import { createClient, createConfig } from \"@hey-api/client-fetch\";\nimport {\n  defaultChromaClientArgs as defaultArgs,\n  HttpMethod,\n  normalizeMethod,\n  parseConnectionPath,\n  deserializeMetadata,\n  serializeMetadata,\n} from \"./utils\";\nimport { DefaultService as Api, ChecklistResponse } from \"./api\";\nimport { CollectionMetadata, UserIdentity } from \"./types\";\nimport { Collection, CollectionImpl } from \"./collection\";\nimport { EmbeddingFunction, getEmbeddingFunction } from \"./embedding-function\";\nimport { chromaFetch } from \"./chroma-fetch\";\nimport * as process from \"node:process\";\nimport {\n  ChromaConnectionError,\n  ChromaUnauthorizedError,\n  ChromaValueError,\n} from \"./errors\";\nimport {\n  CreateCollectionConfiguration,\n  processCreateCollectionConfig,\n} from \"./collection-configuration\";\nimport { EMBEDDING_KEY, Schema } from \"./schema\";\nimport { client } from \"./api/client.gen\";\n\nconst resolveSchemaEmbeddingFunction = (\n  schema: Schema | undefined,\n): EmbeddingFunction | undefined => {\n  if (!schema) {\n    return undefined;\n  }\n\n  const embeddingOverride =\n    schema.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config\n      .embeddingFunction ?? undefined;\n  if (embeddingOverride) {\n    return embeddingOverride;\n  }\n\n  return (\n    schema.defaults.floatList?.vectorIndex?.config.embeddingFunction ??\n    undefined\n  );\n};\n\n/**\n * Configuration options for the ChromaClient.\n */\nexport interface ChromaClientArgs {\n  /** The host address of the Chroma server. Defaults to 'localhost' */\n  host?: string;\n  /** The port number of the Chroma server. Defaults to 8000 */\n  port?: number;\n  /** Whether to use SSL/HTTPS for connections. Defaults to false */\n  ssl?: boolean;\n  /** The tenant name in the Chroma server to connect to */\n  tenant?: string;\n  /** The database name to connect to */\n  database?: string;\n  /** Additional HTTP headers to send with requests */\n  headers?: Record<string, string>;\n  /** Additional fetch options for HTTP requests */\n  fetchOptions?: RequestInit;\n  /** @deprecated Use host, port, and ssl instead */\n  path?: string;\n  /** @deprecated */\n  auth?: Record<string, string>;\n}\n\n/**\n * Main client class for interacting with ChromaDB.\n * Provides methods for managing collections and performing operations on them.\n */\nexport class ChromaClient {\n  private _tenant: string | undefined;\n  private _database: string | undefined;\n  private _preflightChecks: ChecklistResponse | undefined;\n  private _headers: Record<string, string> | undefined;\n  private readonly apiClient: ReturnType<typeof createClient>;\n\n  /**\n   * Creates a new ChromaClient instance.\n   * @param args - Configuration options for the client\n   */\n  constructor(args: Partial<ChromaClientArgs> = {}) {\n    let {\n      host = defaultArgs.host,\n      port = defaultArgs.port,\n      ssl = defaultArgs.ssl,\n      tenant = defaultArgs.tenant,\n      database = defaultArgs.database,\n      headers = defaultArgs.headers,\n      fetchOptions = defaultArgs.fetchOptions,\n    } = args;\n\n    if (args.path) {\n      console.warn(\n        \"The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead\",\n      );\n      const parsedPath = parseConnectionPath(args.path);\n      ssl = parsedPath.ssl;\n      host = parsedPath.host;\n      port = parsedPath.port;\n    }\n\n    if (args.auth) {\n      console.warn(\n        \"The 'auth' argument is deprecated. Please use 'headers' instead\",\n      );\n      if (!headers) {\n        headers = {};\n      }\n      if (\n        !headers[\"x-chroma-token\"] &&\n        args.auth.tokenHeaderType === \"X_CHROMA_TOKEN\" &&\n        args.auth.credentials\n      ) {\n        headers[\"x-chroma-token\"] = args.auth.credentials;\n      }\n    }\n\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n\n    this._tenant = tenant || process.env.CHROMA_TENANT;\n    this._database = database || process.env.CHROMA_DATABASE;\n\n    this._headers = headers;\n\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method) as HttpMethod,\n      baseUrl,\n      headers,\n    };\n\n    this.apiClient = createClient(createConfig(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n\n  /**\n   * Gets the current tenant name.\n   * @returns The tenant name or undefined if not set\n   */\n  public get tenant(): string | undefined {\n    return this._tenant;\n  }\n\n  protected set tenant(tenant: string | undefined) {\n    this._tenant = tenant;\n  }\n\n  /**\n   * Gets the current database name.\n   * @returns The database name or undefined if not set\n   */\n  public get database(): string | undefined {\n    return this._database;\n  }\n\n  protected set database(database: string | undefined) {\n    this._database = database;\n  }\n\n  /**\n   * Gets the preflight checks\n   * @returns The preflight checks or undefined if not set\n   */\n  public get preflightChecks(): ChecklistResponse | undefined {\n    return this._preflightChecks;\n  }\n\n  protected set preflightChecks(\n    preflightChecks: ChecklistResponse | undefined,\n  ) {\n    this._preflightChecks = preflightChecks;\n  }\n\n  public get headers(): Record<string, string> | undefined {\n    return this._headers;\n  }\n\n  /** @ignore */\n  public async _path(): Promise<{ tenant: string; database: string }> {\n    if (!this._tenant || !this._database) {\n      const { tenant, databases } = await this.getUserIdentity();\n      const uniqueDBs = [...new Set(databases)];\n      this._tenant = tenant;\n      if (uniqueDBs.length === 0) {\n        throw new ChromaUnauthorizedError(\n          `Your API key does not have access to any DBs for tenant ${this.tenant}`,\n        );\n      }\n      if (uniqueDBs.length > 1 || uniqueDBs[0] === \"*\") {\n        throw new ChromaValueError(\n          \"Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor\",\n        );\n      }\n      this._database = uniqueDBs[0];\n    }\n    return { tenant: this._tenant, database: this._database };\n  }\n\n  /**\n   * Gets the user identity information including tenant and accessible databases.\n   * @returns Promise resolving to user identity data\n   */\n  public async getUserIdentity(): Promise<UserIdentity> {\n    const { data } = await Api.getUserIdentity({\n      client: this.apiClient,\n    });\n    return data;\n  }\n\n  /**\n   * Sends a heartbeat request to check server connectivity.\n   * @returns Promise resolving to the server's nanosecond heartbeat timestamp\n   */\n  public async heartbeat(): Promise<number> {\n    const { data } = await Api.heartbeat({\n      client: this.apiClient,\n    });\n    return data[\"nanosecond heartbeat\"];\n  }\n\n  /**\n   * Lists all collections in the current database.\n   * @param args - Optional pagination parameters\n   * @param args.limit - Maximum number of collections to return (default: 100)\n   * @param args.offset - Number of collections to skip (default: 0)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  public async listCollections(\n    args?: Partial<{\n      limit: number;\n      offset: number;\n    }>,\n  ): Promise<Collection[]> {\n    const { limit = 100, offset = 0 } = args || {};\n\n    const { data } = await Api.listCollections({\n      client: this.apiClient,\n      path: await this._path(),\n      query: { limit, offset },\n    });\n\n    return Promise.all(\n      data.map(async (collection) => {\n        const schema = await Schema.deserializeFromJSON(\n          collection.schema ?? null,\n          this,\n        );\n        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n        const resolvedEmbeddingFunction =\n          (await getEmbeddingFunction({\n            collectionName: collection.name,\n            client: this,\n            efConfig:\n              collection.configuration_json.embedding_function ?? undefined,\n          })) ?? schemaEmbeddingFunction;\n\n        return new CollectionImpl({\n          chromaClient: this,\n          apiClient: this.apiClient,\n          tenant: collection.tenant,\n          database: collection.database,\n          name: collection.name,\n          id: collection.id,\n          embeddingFunction: resolvedEmbeddingFunction,\n          configuration: collection.configuration_json,\n          metadata:\n            deserializeMetadata(collection.metadata ?? undefined) ?? undefined,\n          schema,\n        });\n      }),\n    );\n  }\n\n  /**\n   * Gets the total number of collections in the current database.\n   * @returns Promise resolving to the collection count\n   */\n  public async countCollections(): Promise<number> {\n    const { data } = await Api.countCollections({\n      client: this.apiClient,\n      path: await this._path(),\n    });\n\n    return data;\n  }\n\n  /**\n   * Creates a new collection with the specified configuration.\n   * @param options - Collection creation options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration\n   * @param options.metadata - Optional metadata for the collection\n   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed\n   * @returns Promise resolving to the created Collection instance\n   * @throws Error if a collection with the same name already exists\n   */\n  public async createCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema,\n  }: {\n    name: string;\n    configuration?: CreateCollectionConfiguration;\n    metadata?: CollectionMetadata;\n    embeddingFunction?: EmbeddingFunction | null;\n    schema?: Schema;\n  }): Promise<Collection> {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema,\n    });\n\n    const { data } = await Api.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: false,\n        schema: schema ? schema.serializeToJSON() : undefined,\n      },\n    });\n\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this,\n    );\n    const schemaEmbeddingFunction =\n      resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        client: this,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema,\n    });\n  }\n\n  /**\n   * Retrieves an existing collection by name.\n   * @param options - Collection retrieval options\n   * @param options.name - The name of the collection to retrieve\n   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  public async getCollection({\n    name,\n    embeddingFunction,\n  }: {\n    name: string;\n    embeddingFunction?: EmbeddingFunction;\n  }): Promise<Collection> {\n    const { data } = await Api.getCollection({\n      client: this.apiClient,\n      path: { ...(await this._path()), collection_id: name },\n    });\n\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        client: this,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema,\n    });\n  }\n\n  /**\n   * Retrieves an existing collection by its Chroma Resource Name (CRN).\n   * @param crn - The Chroma Resource Name of the collection to retrieve\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  public async getCollectionByCrn(crn: string): Promise<Collection> {\n    const { data } = await Api.getCollectionByCrn({\n      client: this.apiClient,\n      path: { crn },\n    });\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction =\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n        client: this,\n      })) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema,\n    });\n  }\n\n  /**\n   * Retrieves multiple collections by name.\n   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  public async getCollections(\n    items: string[] | { name: string; embeddingFunction?: EmbeddingFunction }[],\n  ): Promise<Collection[]> {\n    if (items.length === 0) return [];\n\n    let requestedCollections = items;\n    if (typeof items[0] === \"string\") {\n      requestedCollections = (items as string[]).map((item) => {\n        return { name: item, embeddingFunction: undefined };\n      });\n    }\n\n    let collections = requestedCollections as {\n      name: string;\n      embeddingFunction?: EmbeddingFunction;\n    }[];\n\n    return Promise.all(\n      collections.map(async (collection) => {\n        return this.getCollection({ ...collection });\n      }),\n    );\n  }\n\n  /**\n   * Gets an existing collection or creates it if it doesn't exist.\n   * @param options - Collection options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration (used only if creating)\n   * @param options.metadata - Optional metadata for the collection (used only if creating)\n   * @param options.embeddingFunction - Optional embedding function to use\n   * @returns Promise resolving to the Collection instance\n   */\n  public async getOrCreateCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema,\n  }: {\n    name: string;\n    configuration?: CreateCollectionConfiguration;\n    metadata?: CollectionMetadata;\n    embeddingFunction?: EmbeddingFunction | null;\n    schema?: Schema;\n  }): Promise<Collection> {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema,\n    });\n\n    const { data } = await Api.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: true,\n        schema: schema ? schema.serializeToJSON() : undefined,\n      },\n    });\n\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this,\n    );\n    const schemaEmbeddingFunction =\n      resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: name,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n        client: this,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema,\n    });\n  }\n\n  /**\n   * Deletes a collection and all its data.\n   * @param options - Deletion options\n   * @param options.name - The name of the collection to delete\n   */\n  public async deleteCollection({ name }: { name: string }): Promise<void> {\n    await Api.deleteCollection({\n      client: this.apiClient,\n      path: { ...(await this._path()), collection_id: name },\n    });\n  }\n\n  /**\n   * Resets the entire database, deleting all collections and data.\n   * @returns Promise that resolves when the reset is complete\n   * @warning This operation is irreversible and will delete all data\n   */\n  public async reset(): Promise<void> {\n    await Api.reset({\n      client: this.apiClient,\n    });\n  }\n\n  /**\n   * Gets the version of the Chroma server.\n   * @returns Promise resolving to the server version string\n   */\n  public async version(): Promise<string> {\n    const { data } = await Api.version({\n      client: this.apiClient,\n    });\n    return data;\n  }\n\n  /**\n   * Gets the preflight checks\n   * @returns Promise resolving to the preflight checks\n   */\n  public async getPreflightChecks(): Promise<ChecklistResponse> {\n    if (!this.preflightChecks) {\n      const { data } = await Api.preFlightChecks({\n        client: this.apiClient,\n      });\n      this.preflightChecks = data;\n      return this.preflightChecks;\n    }\n    return this.preflightChecks;\n  }\n\n  /**\n   * Gets the max batch size\n   * @returns Promise resolving to the max batch size\n   */\n  public async getMaxBatchSize(): Promise<number> {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.max_batch_size ?? -1;\n  }\n\n  /**\n   * Gets whether base64_encoding is supported by the connected server\n   * @returns Promise resolving to whether base64_encoding is supported\n   */\n  public async supportsBase64Encoding(): Promise<boolean> {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.supports_base64_encoding ?? false;\n  }\n}\n","import { ChromaClient } from \"./chroma-client\";\nimport * as process from \"node:process\";\nimport { AdminClient } from \"./admin-client\";\nimport { ChromaUnauthorizedError, ChromaValueError } from \"./errors\";\n\n/**\n * ChromaDB cloud client for connecting to hosted Chroma instances.\n * Extends ChromaClient with cloud-specific authentication and configuration.\n */\nexport class CloudClient extends ChromaClient {\n  /**\n   * Creates a new CloudClient instance for Chroma Cloud.\n   * @param args - Cloud client configuration options\n   */\n  constructor(\n    args: Partial<{\n      /** API key for authentication (or set CHROMA_API_KEY env var) */\n      apiKey?: string;\n      /** Host address of the Chroma cloud server. Defaults to 'api.trychroma.com' */\n      host?: string;\n      /** Port number of the Chroma cloud server. Defaults to 443 */\n      port?: number;\n      /** Tenant name for multi-tenant deployments */\n      tenant?: string;\n      /** Database name to connect to */\n      database?: string;\n      /** Additional fetch options for HTTP requests */\n      fetchOptions?: RequestInit;\n    }> = {},\n  ) {\n    const apiKey = args.apiKey || process.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\",\n      );\n    }\n\n    const tenant = args.tenant || process.env.CHROMA_TENANT;\n    const database = args.database || process.env.CHROMA_DATABASE;\n\n    super({\n      host: args.host || \"api.trychroma.com\",\n      port: args.port || 443,\n      ssl: true,\n      tenant,\n      database,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions,\n    });\n\n    // Override from ChromaClient construction in case undefined. This will trigger auto-resolution in the \"path\" function\n    this.tenant = tenant;\n    this.database = database;\n  }\n}\n\n/**\n * Admin client for Chroma Cloud administrative operations.\n * Extends AdminClient with cloud-specific authentication.\n */\nexport class AdminCloudClient extends AdminClient {\n  /**\n   * Creates a new AdminCloudClient instance for cloud admin operations.\n   * @param args - Admin cloud client configuration options\n   */\n  constructor(\n    args: Partial<{\n      /** API key for authentication (or set CHROMA_API_KEY env var) */\n      apiKey?: string;\n      /** Host address of the Chroma cloud server. Defaults to 'api.trychroma.com' */\n      host?: string;\n      /** Port number of the Chroma cloud server. Defaults to 443 */\n      port?: number;\n      /** Additional fetch options for HTTP requests */\n      fetchOptions?: RequestInit;\n    }> = {},\n  ) {\n    const apiKey = args.apiKey || process.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\",\n      );\n    }\n\n    super({\n      host: args.host || \"api.trychroma.com\",\n      port: args.port || 443,\n      ssl: true,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions,\n    });\n  }\n}\n"],"mappings":"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","names":["IncludeEnum","q","getAuthToken","auth","callback","token","getAuthToken","jsonBodySerializer","body","key","value","getAuthToken","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","value","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","url","matches","match","h","g","c","replaceValue","createQuerySerializer","array","object","queryParams","search","getParseAs","contentType","cleanContent","type","setAuthParams","security","options","auth","token","x","buildUrl","getUrl","baseUrl","query","querySerializer","pathUrl","mergeConfigs","a","b","config","mergeHeaders","headers","mergedHeaders","header","iterator","Interceptors","fn","index","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","z","createClient","_config","getConfig","setConfig","interceptors","request","opts","requestInit","_fetch","response","result","parseAs","data","error","finalError","_","w","client","client","CmekProvider","client","sparseEmbeddings","process"]}