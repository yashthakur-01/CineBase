{"version":3,"file":"rerank.cjs","names":["BaseDocumentCompressor","fields?: CohereRerankArgs","getCohereClient","documents: Array<DocumentInterface>","query: string","finalResults: Array<DocumentInterface>","documents: Array<DocumentInterface | string | Record<string, string>>","options?: {\n      model?: string;\n      topN?: number;\n      maxChunksPerDoc?: number;\n    }"],"sources":["../src/rerank.ts"],"sourcesContent":["import { DocumentInterface } from \"@langchain/core/documents\";\nimport { BaseDocumentCompressor } from \"@langchain/core/retrievers/document_compressors\";\nimport { CohereClient } from \"cohere-ai\";\nimport { CohereClientOptions, getCohereClient } from \"./client.js\";\n\nexport interface BaseCohereRerankArgs {\n  /**\n   * The name of the model to use.\n   * @default {\"rerank-english-v2.0\"}\n   */\n  model?: string;\n  /**\n   * How many documents to return.\n   * @default {3}\n   */\n  topN?: number;\n  /**\n   * The maximum number of chunks per document.\n   */\n  maxChunksPerDoc?: number;\n}\n\ntype CohereRerankArgs = BaseCohereRerankArgs & CohereClientOptions;\n/**\n * Document compressor that uses `Cohere Rerank API`.\n */\nexport class CohereRerank extends BaseDocumentCompressor {\n  model: string | undefined;\n\n  topN = 3;\n\n  client: CohereClient;\n\n  maxChunksPerDoc: number | undefined;\n\n  constructor(fields?: CohereRerankArgs) {\n    super();\n\n    this.client = getCohereClient(fields);\n\n    this.model = fields?.model ?? this.model;\n    if (!this.model) {\n      throw new Error(\n        \"Model not specified for CohereRerank instance. Please provide a model name from the options here: https://docs.cohere.com/reference/rerank\"\n      );\n    }\n    this.topN = fields?.topN ?? this.topN;\n    this.maxChunksPerDoc = fields?.maxChunksPerDoc;\n  }\n\n  /**\n   * Compress documents using Cohere's rerank API.\n   *\n   * @param {Array<DocumentInterface>} documents A sequence of documents to compress.\n   * @param {string} query The query to use for compressing the documents.\n   *\n   * @returns {Promise<Array<DocumentInterface>>} A sequence of compressed documents.\n   */\n  async compressDocuments(\n    documents: Array<DocumentInterface>,\n    query: string\n  ): Promise<Array<DocumentInterface>> {\n    if (documents == null || documents.length === 0) {\n      return [];\n    }\n    const _docs = documents.map((doc) => doc.pageContent);\n    const { results } = await this.client.rerank({\n      model: this.model,\n      query,\n      documents: _docs,\n      topN: this.topN,\n      maxChunksPerDoc: this.maxChunksPerDoc,\n    });\n    const finalResults: Array<DocumentInterface> = [];\n    for (let i = 0; i < results.length; i += 1) {\n      const result = results[i];\n      const doc = documents[result.index];\n      doc.metadata.relevanceScore = result.relevanceScore;\n      finalResults.push(doc);\n    }\n    return finalResults;\n  }\n\n  /**\n   * Returns an ordered list of documents ordered by their relevance to the provided query.\n   *\n   * @param {Array<DocumentInterface | string | Record<string, string>>} documents A list of documents as strings, DocumentInterfaces or objects with a `pageContent` key.\n   * @param {string} query The query to use for reranking the documents.\n   * @param options\n   * @param {string} options.model The name of the model to use.\n   * @param {number} options.topN How many documents to return.\n   * @param {number} options.maxChunksPerDoc The maximum number of chunks per document.\n   *\n   * @returns {Promise<Array<{ index: number; relevanceScore: number }>>} An ordered list of documents with relevance scores.\n   */\n  async rerank(\n    documents: Array<DocumentInterface | string | Record<string, string>>,\n    query: string,\n    options?: {\n      model?: string;\n      topN?: number;\n      maxChunksPerDoc?: number;\n    }\n  ): Promise<Array<{ index: number; relevanceScore: number }>> {\n    const docs = documents.map((doc) => {\n      if (typeof doc === \"string\") {\n        return doc;\n      }\n      return doc.pageContent;\n    });\n    const model = options?.model ?? this.model;\n    const topN = options?.topN ?? this.topN;\n    const maxChunksPerDoc = options?.maxChunksPerDoc ?? this.maxChunksPerDoc;\n    const { results } = await this.client.rerank({\n      model,\n      query,\n      documents: docs,\n      topN,\n      maxChunksPerDoc,\n    });\n\n    const resultObjects = results.map((result) => ({\n      index: result.index,\n      relevanceScore: result.relevanceScore,\n    }));\n    return resultObjects;\n  }\n}\n"],"mappings":";;;;;;;;AA0BA,IAAa,eAAb,cAAkCA,wEAAuB;CACvD;CAEA,OAAO;CAEP;CAEA;CAEA,YAAYC,QAA2B;EACrC,OAAO;EAEP,KAAK,SAASC,+BAAgB,OAAO;EAErC,KAAK,QAAQ,QAAQ,SAAS,KAAK;AACnC,MAAI,CAAC,KAAK,MACR,OAAM,IAAI,MACR;EAGJ,KAAK,OAAO,QAAQ,QAAQ,KAAK;EACjC,KAAK,kBAAkB,QAAQ;CAChC;;;;;;;;;CAUD,MAAM,kBACJC,WACAC,OACmC;AACnC,MAAI,aAAa,QAAQ,UAAU,WAAW,EAC5C,QAAO,CAAE;EAEX,MAAM,QAAQ,UAAU,IAAI,CAAC,QAAQ,IAAI,YAAY;EACrD,MAAM,EAAE,SAAS,GAAG,MAAM,KAAK,OAAO,OAAO;GAC3C,OAAO,KAAK;GACZ;GACA,WAAW;GACX,MAAM,KAAK;GACX,iBAAiB,KAAK;EACvB,EAAC;EACF,MAAMC,eAAyC,CAAE;AACjD,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,GAAG;GAC1C,MAAM,SAAS,QAAQ;GACvB,MAAM,MAAM,UAAU,OAAO;GAC7B,IAAI,SAAS,iBAAiB,OAAO;GACrC,aAAa,KAAK,IAAI;EACvB;AACD,SAAO;CACR;;;;;;;;;;;;;CAcD,MAAM,OACJC,WACAF,OACAG,SAK2D;EAC3D,MAAM,OAAO,UAAU,IAAI,CAAC,QAAQ;AAClC,OAAI,OAAO,QAAQ,SACjB,QAAO;AAET,UAAO,IAAI;EACZ,EAAC;EACF,MAAM,QAAQ,SAAS,SAAS,KAAK;EACrC,MAAM,OAAO,SAAS,QAAQ,KAAK;EACnC,MAAM,kBAAkB,SAAS,mBAAmB,KAAK;EACzD,MAAM,EAAE,SAAS,GAAG,MAAM,KAAK,OAAO,OAAO;GAC3C;GACA;GACA,WAAW;GACX;GACA;EACD,EAAC;EAEF,MAAM,gBAAgB,QAAQ,IAAI,CAAC,YAAY;GAC7C,OAAO,OAAO;GACd,gBAAgB,OAAO;EACxB,GAAE;AACH,SAAO;CACR;AACF"}