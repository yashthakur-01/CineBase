{"version":3,"file":"llms.js","names":["fields?: CohereInput","options: this[\"ParsedCallOptions\"]","prompt: string","runManager?: CallbackManagerForLLMRun","e: any"],"sources":["../src/llms.ts"],"sourcesContent":["import { CohereClient, Cohere as CohereTypes } from \"cohere-ai\";\n\nimport { LLM, type BaseLLMParams } from \"@langchain/core/language_models/llms\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport type { BaseLanguageModelCallOptions } from \"@langchain/core/language_models/base\";\nimport { CohereClientOptions, getCohereClient } from \"./client.js\";\n\n/**\n * Interface for the input parameters specific to the Cohere model.\n */\nexport interface BaseCohereInput extends BaseLLMParams {\n  /** Sampling temperature to use */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate in the completion.\n   */\n  maxTokens?: number;\n\n  /** Model to use */\n  model?: string;\n}\n\nexport type CohereInput = BaseCohereInput & CohereClientOptions;\n\ninterface CohereCallOptions\n  extends BaseLanguageModelCallOptions,\n    Partial<Omit<CohereTypes.GenerateRequest, \"message\">> {}\n\n/**\n * Class representing a Cohere Large Language Model (LLM). It interacts\n * with the Cohere API to generate text completions.\n * @example\n * ```typescript\n * const model = new Cohere({\n *   temperature: 0.7,\n *   maxTokens: 20,\n *   maxRetries: 5,\n * });\n *\n * const res = await model.invoke(\n *   \"Question: What would be a good company name for a company that makes colorful socks?\\nAnswer:\"\n * );\n * console.log({ res });\n * ```\n */\nexport class Cohere extends LLM<CohereCallOptions> implements CohereInput {\n  static lc_name() {\n    return \"Cohere\";\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return {\n      apiKey: \"COHERE_API_KEY\",\n      api_key: \"COHERE_API_KEY\",\n    };\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return {\n      apiKey: \"cohere_api_key\",\n      api_key: \"cohere_api_key\",\n    };\n  }\n\n  lc_serializable = true;\n\n  temperature = 0;\n\n  maxTokens = 250;\n\n  model: string;\n\n  apiKey: string;\n\n  client: CohereClient;\n\n  constructor(fields?: CohereInput) {\n    super(fields ?? {});\n\n    this.client = getCohereClient(fields);\n    this.maxTokens = fields?.maxTokens ?? this.maxTokens;\n    this.temperature = fields?.temperature ?? this.temperature;\n    this.model = fields?.model ?? this.model;\n  }\n\n  _llmType() {\n    return \"cohere\";\n  }\n\n  invocationParams(options: this[\"ParsedCallOptions\"]) {\n    const params = {\n      model: this.model,\n      numGenerations: options.numGenerations,\n      maxTokens: options.maxTokens ?? this.maxTokens,\n      truncate: options.truncate,\n      temperature: options.temperature ?? this.temperature,\n      preset: options.preset,\n      endSequences: options.endSequences,\n      stopSequences: options.stop ?? options.stopSequences,\n      k: options.k,\n      p: options.p,\n      frequencyPenalty: options.frequencyPenalty,\n      presencePenalty: options.presencePenalty,\n      returnLikelihoods: options.returnLikelihoods,\n    };\n    // Filter undefined entries\n    return Object.fromEntries(\n      Object.entries(params).filter(([, value]) => value !== undefined)\n    );\n  }\n\n  /** @ignore */\n  async _call(\n    prompt: string,\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string> {\n    const generateResponse = await this.caller.callWithOptions(\n      { signal: options.signal },\n      async () => {\n        let response;\n        try {\n          response = await this.client.generate({\n            prompt,\n            ...this.invocationParams(options),\n          });\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          e.status = e.status ?? e.statusCode;\n          throw e;\n        }\n        return response;\n      }\n    );\n    try {\n      await runManager?.handleLLMNewToken(generateResponse.generations[0].text);\n      return generateResponse.generations[0].text;\n    } catch {\n      console.log(generateResponse);\n      throw new Error(\"Could not parse response.\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AA8CA,IAAa,SAAb,cAA4B,IAA8C;CACxE,OAAO,UAAU;AACf,SAAO;CACR;CAED,IAAI,aAAoD;AACtD,SAAO;GACL,QAAQ;GACR,SAAS;EACV;CACF;CAED,IAAI,aAAoD;AACtD,SAAO;GACL,QAAQ;GACR,SAAS;EACV;CACF;CAED,kBAAkB;CAElB,cAAc;CAEd,YAAY;CAEZ;CAEA;CAEA;CAEA,YAAYA,QAAsB;EAChC,MAAM,UAAU,CAAE,EAAC;EAEnB,KAAK,SAAS,gBAAgB,OAAO;EACrC,KAAK,YAAY,QAAQ,aAAa,KAAK;EAC3C,KAAK,cAAc,QAAQ,eAAe,KAAK;EAC/C,KAAK,QAAQ,QAAQ,SAAS,KAAK;CACpC;CAED,WAAW;AACT,SAAO;CACR;CAED,iBAAiBC,SAAoC;EACnD,MAAM,SAAS;GACb,OAAO,KAAK;GACZ,gBAAgB,QAAQ;GACxB,WAAW,QAAQ,aAAa,KAAK;GACrC,UAAU,QAAQ;GAClB,aAAa,QAAQ,eAAe,KAAK;GACzC,QAAQ,QAAQ;GAChB,cAAc,QAAQ;GACtB,eAAe,QAAQ,QAAQ,QAAQ;GACvC,GAAG,QAAQ;GACX,GAAG,QAAQ;GACX,kBAAkB,QAAQ;GAC1B,iBAAiB,QAAQ;GACzB,mBAAmB,QAAQ;EAC5B;AAED,SAAO,OAAO,YACZ,OAAO,QAAQ,OAAO,CAAC,OAAO,CAAC,GAAG,MAAM,KAAK,UAAU,OAAU,CAClE;CACF;;CAGD,MAAM,MACJC,QACAD,SACAE,YACiB;EACjB,MAAM,mBAAmB,MAAM,KAAK,OAAO,gBACzC,EAAE,QAAQ,QAAQ,OAAQ,GAC1B,YAAY;GACV,IAAI;AACJ,OAAI;IACF,WAAW,MAAM,KAAK,OAAO,SAAS;KACpC;KACA,GAAG,KAAK,iBAAiB,QAAQ;IAClC,EAAC;GAEH,SAAQC,GAAQ;IACf,EAAE,SAAS,EAAE,UAAU,EAAE;AACzB,UAAM;GACP;AACD,UAAO;EACR,EACF;AACD,MAAI;GACF,MAAM,YAAY,kBAAkB,iBAAiB,YAAY,GAAG,KAAK;AACzE,UAAO,iBAAiB,YAAY,GAAG;EACxC,QAAO;GACN,QAAQ,IAAI,iBAAiB;AAC7B,SAAM,IAAI,MAAM;EACjB;CACF;AACF"}